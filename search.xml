<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Java基础】 IO体系中的各种高级流</title>
      <link href="/2025/05/12/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%20IO%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%AB%98%E7%BA%A7%E6%B5%81/"/>
      <url>/2025/05/12/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%20IO%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%AB%98%E7%BA%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p><img src="https://pic1.imgdb.cn/item/6821ff7158cb8da5c8eeb231.png" alt="缓冲流"></p><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>原理： 底层自带了长度为<code>8192</code>(字节)的缓冲区提高性能</p><div class="table-container"><table><thead><tr><th>构造器</th><th>使用</th></tr></thead><tbody><tr><td>public BufferedInputStream(InputStream is)</td><td>把基本流<code>包装</code>成高级流，提高<code>读取数据</code>的性能</td></tr><tr><td>public BufferedOutputStream(OutputStream os)</td><td>把基本流<code>包装</code>成高级流，提高<code>写出数据</code>的性能</td></tr></tbody></table></div><h4 id="单字节拷贝"><a href="#单字节拷贝" class="headerlink" title="单字节拷贝"></a>单字节拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedInputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建 BufferedInputStream 读取数据对象</span><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>));<br>        <span class="hljs-comment">// 创建 BufferedOutputStream 写出数据对象</span><br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copyIO.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">while</span>((b = bis.read()) != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 写入数据</span><br>            bos.write(b);<br>        &#125;<br><br>        bos.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多字节拷贝"><a href="#多字节拷贝" class="headerlink" title="多字节拷贝"></a>多字节拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedInputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建 BufferedInputStream 读取数据对象</span><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>));<br>        <span class="hljs-comment">// 创建 BufferedOutputStream 写出数据对象</span><br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copyIO.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">while</span>((b = bis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 写入数据</span><br>            bos.write(bytes,<span class="hljs-number">0</span>,b);<br>        &#125;<br><br>        bos.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字节缓冲流读写原理"><a href="#字节缓冲流读写原理" class="headerlink" title="字节缓冲流读写原理"></a>字节缓冲流读写原理</h4><p><img src="https://pic1.imgdb.cn/item/6821ff7258cb8da5c8eeb23b.png" alt="缓冲流"></p><ol><li>基本流读取数据放在缓冲区中，一次性读取8192个字节</li><li>变量b在内存中不断将左边缓冲区中的数据一个一个的放入右边的缓冲区中</li><li>右边缓冲区装满时，自动写入到目标文件</li></ol><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><div class="table-container"><table><thead><tr><th>构造器</th><th>使用</th></tr></thead><tbody><tr><td>public BufferedReader(Reader r)</td><td>把基本流包装为高级流</td></tr><tr><td>public BufferedWriter(Wruter r)</td><td>把基本流包装为高级流</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>特有方法</th><th>使用</th></tr></thead><tbody><tr><td>public String readLine()</td><td>读取一行数据，如果没有数据可读，返回null</td></tr><tr><td>public void newLine()</td><td>跨平台的换行</td></tr></tbody></table></div><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>转换流是字符流和字节流之间的桥梁</p><p>作用: </p><pre><code class="hljs">1. 指定字符集进行读写数据（JDK11之后淘汰）2. 字节流想要使用字符流的方法</code></pre><hr><h3 id="指定字母编码格式读取数据"><a href="#指定字母编码格式读取数据" class="headerlink" title="指定字母编码格式读取数据"></a>指定字母编码格式读取数据</h3><ol><li><p>JDK11之前</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建对象并指定字符编码</span><br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>), <span class="hljs-string">&quot;GBK&quot;</span>);<br><br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-type">int</span> ch;<br><span class="hljs-keyword">while</span>((ch = isr.read()) != -<span class="hljs-number">1</span>)&#123;<br>    System.out.print((<span class="hljs-type">char</span>)ch);<br>&#125;<br><br><span class="hljs-comment">// 释放资源</span><br>isr.close();<br></code></pre></td></tr></table></figure></li><li><p>JDK11之后</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建对象并指定字符编码</span><br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>,Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>));<br><br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-type">int</span> ch;<br><span class="hljs-keyword">while</span>((ch = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>    System.out.print((<span class="hljs-type">char</span>)ch);<br>&#125;<br><br><span class="hljs-comment">// 释放资源</span><br>fr.close();<br></code></pre></td></tr></table></figure></li></ol><h3 id="指定字符编码格式写出数据"><a href="#指定字符编码格式写出数据" class="headerlink" title="指定字符编码格式写出数据"></a>指定字符编码格式写出数据</h3><ol><li><p>JDK11之前</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建转换流对象</span><br><span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>),<span class="hljs-string">&quot;GBK&quot;</span>);<br><br><span class="hljs-comment">// 写出数据</span><br>osw.write(<span class="hljs-string">&quot;神不惧死亡&quot;</span>);<br><br><span class="hljs-comment">// 释放资源</span><br>osw.close();<br></code></pre></td></tr></table></figure></li><li><p>JDK11之后</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 直接创建FileWriter对象</span><br><span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>,Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>));<br><br><span class="hljs-comment">// 写入数据</span><br>fw.write(<span class="hljs-string">&quot;神不惧死亡&quot;</span>);<br><br><span class="hljs-comment">// 释放资源</span><br>fw.close();<br></code></pre></td></tr></table></figure></li></ol><h3 id="将本地GBK文件转为UTF-8文件"><a href="#将本地GBK文件转为UTF-8文件" class="headerlink" title="将本地GBK文件转为UTF-8文件"></a>将本地GBK文件转为UTF-8文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建读取对象</span><br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>,Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>));<br>        <span class="hljs-comment">// 创建写入对象</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;IOUTF.txt&quot;</span>,Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br><br>        <span class="hljs-comment">// 读取数据</span><br>        <span class="hljs-type">int</span> ch;<br>        <span class="hljs-keyword">while</span>((ch = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 写入数据</span><br>            fw.write((<span class="hljs-type">char</span>)ch);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭资源 - 先开的后关</span><br>        fw.close();<br>        fr.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="序列化流与反序列化流"><a href="#序列化流与反序列化流" class="headerlink" title="序列化流与反序列化流"></a>序列化流与反序列化流</h2><blockquote><p><code>序列化流</code>可以将Java中的对象写入到本地文件之中，写入之后是看不懂的一堆乱码(类似于：��srStudent/�l�_�QIageLnametLjava/lang/String;xptzhangsan)。但是可以使用<code>反序列化流</code>读取出来以后就可以看懂了</p></blockquote><h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p><strong>将程序中的对象，写入到文件中</strong></p><div class="table-container"><table><thead><tr><th>构造器</th><th>使用</th></tr></thead><tbody><tr><td>public ObjectOutputStream(OutputStream out)</td><td>把基本流包装为高级流</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>成员方法</th><th>使用</th></tr></thead><tbody><tr><td>public final void writeObject(Obejct obj)</td><td>把对象序列化(写出)到文件中</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建要写出到文件中的对象</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">21</span>);<br><br><span class="hljs-comment">// 创建序列化流对象</span><br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>));<br><br><span class="hljs-comment">// 写出对象数据</span><br>oos.writeObject(stu);<br><br><span class="hljs-comment">// 释放资源</span><br>oos.close();<br></code></pre></td></tr></table></figure><blockquote><p>注意：在利用序列化流写出数据时，里面会出现<code>NotSerializableException</code>异常。解决方法是：让对应对象类型的Javabean类(我这边创建的是Student类)实现一个<code>Serializable接口</code>(Serializable接口：里面没有任何抽象方法，为<code>标记型接口</code>，一旦实现这个接口表示当前的javabean类可以被序列化)。</p></blockquote><h3 id="反序列化流"><a href="#反序列化流" class="headerlink" title="反序列化流"></a>反序列化流</h3><p><strong>将文件中的对象，读取到程序中</strong></p><div class="table-container"><table><thead><tr><th>构造器</th><th>使用</th></tr></thead><tbody><tr><td>public ObjectInputStream(InputStream)</td><td>把基本流包装为高级流</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>成员方法</th><th>使用</th></tr></thead><tbody><tr><td>public Object readObject()</td><td>将序列化到本地中的对象，读取到程序中</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建反序列化对象</span><br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>));<br><br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student)ois.readObject();<br><br><span class="hljs-comment">// 打印</span><br>System.out.println(s);<br><br><span class="hljs-comment">// 释放资源</span><br>ois.close();<br></code></pre></td></tr></table></figure><hr><blockquote><p>问题：假设：我们已经使用序列化流将对象写入到本地文件中，但是又在后续对javabean类做了修改，比如添加了一个属性，此时如果我们使用反序列化流从本地文件中读取对象时会发现，程序出现报错。</p><p>原因：如果一个类实现了Serializable接口，那么表示这个类是可被序列化的。此时java底层会根据这个类的所有内容(成员变量，构造方法，成员方法…)进行计算，计算出一个long类型的序列号(版本号)，假如此时计算出的版本号为0011，那么java会将0011版本号记录到本地文件中。如果此时修改javabean内的代码，会计算一个新的版本号，当我们读取本地对象时，两个版本号不一致，所以程序出现错误。</p><p>解决方案:在定义javabean类时定义一个固定的版本号。版本号为私有，不让外界使用，也不提供get,set方法。版本号的变量名一定要写成<code>serialVersionUID</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Serial</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0011L</span>;<br></code></pre></td></tr></table></figure><p><strong>如果一个对象中的某个变量的值不想被序列化，给该成员变量加上<code>transient</code>关键字修饰，表示该成员变量不参与序列化过程。</strong></p><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><blockquote><p>打印流不能读,只能写。打印流只有输出流</p></blockquote><ol><li>打印流只操作文件目的地，不操作数据源</li><li>特有的写出方法可以实现，数据原样写出</li><li>特有的写出方法可以实现，自动换行，自动刷新</li></ol><h3 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流"></a>字节打印流</h3><div class="table-container"><table><thead><tr><th>构造方法</th><th>使用</th></tr></thead><tbody><tr><td>public PrintStream(OutputStream/File/String)</td><td>关联字节输出流/文件/文件路径</td></tr><tr><td>public PrintStream(String fileName, Chatset charset)</td><td>指定字符编码</td></tr><tr><td>public PrintStream(OutputStream os, boolean autoFlush)</td><td>自动刷新</td></tr><tr><td>public PrintStream(OutputStream os, boolean autoFlush, String encoding)</td><td>指定字符编码且自动刷新</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>成员方法</th><th>使用</th></tr></thead><tbody><tr><td>public void write(int b)</td><td>常规方法：将指定字节写出</td></tr><tr><td>public void println(XXX xxx)</td><td>特有方法：打印任意数据，自动刷新换行</td></tr><tr><td>public void print(XXX xxx)</td><td>特有方法：打印任意数据，不换行</td></tr><tr><td>public void printf(String format, Object… args)</td><td>特有方法：带占位符的打印，不换行</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建字节打印流</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;io.txt&quot;</span>);<br><br><span class="hljs-comment">// 写出数据</span><br>ps.println(<span class="hljs-string">&quot;岂不闻光阴如骏马加鞭&quot;</span>);<br>ps.println(<span class="hljs-string">&quot;岁月如落花流水&quot;</span>);<br><br><span class="hljs-comment">// 释放资源</span><br>ps.close();<br></code></pre></td></tr></table></figure><h3 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流"></a>字符打印流</h3><p><strong>字符打印流与字节打印流构造方法与成员方法都是类似，只是底层多了一个缓冲区</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建字节打印流对象</span><br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-string">&quot;io.txt&quot;</span>);<br><br><span class="hljs-comment">// 写出数据</span><br>pw.println(<span class="hljs-string">&quot;岂不闻天无绝人之路&quot;</span>);<br>pw.println(<span class="hljs-string">&quot;只要我想走，路就在脚下&quot;</span>);<br><br><span class="hljs-comment">// 释放资源</span><br>pw.close();<br></code></pre></td></tr></table></figure><h3 id="输出语句与打印流之间的关系"><a href="#输出语句与打印流之间的关系" class="headerlink" title="输出语句与打印流之间的关系"></a>输出语句与打印流之间的关系</h3><blockquote><p>输出语句其实底层用的就是打印流。如果进入<code>System</code>类，可以看见，<code>out</code>是System中一个<code>PrintStream</code>类的静态变量，那么<code>System.out.peintln</code>，其实就是通过System类调用out静态变量，然后在调用PrintStream中的<code>println()</code>方法。out这个<code>打印流对象</code>，是在虚拟机启动时，由虚拟机自动创建的。out打印流对象默认指向控制台，也可以把它称为：<code>系统中的标准输出流</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
