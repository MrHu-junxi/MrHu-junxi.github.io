<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iHRM人力资源后台管理-基础架构解析</title>
      <link href="/2025/05/15/Vue/iHRM%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/1.%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/05/15/Vue/iHRM%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/1.%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该项目是<a href="https://www.itheima.com/">黑马程序员</a>为学习<code>Vue</code>的初学者特地准备的<code>Vue人力资源后台管理系统项目</code>，觉得不错的可以去B站搜索<code>黑马程序员</code>，关注收藏一下。本人也非常喜欢黑马的课程，非常适合新手，不要在乎别人的流言蜚语，感兴趣的小伙伴可以一起学习，变得更强。加油！！！</p></blockquote><p><img src="https://pic1.imgdb.cn/item/682585db58cb8da5c8f28805.png" alt="项目介绍"></p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目架构："><a href="#项目架构：" class="headerlink" title="项目架构："></a>项目架构：</h3><ol><li>Vue2</li><li>VueRouter</li><li>Vuex</li><li>Vue-cli</li><li>Element</li><li>Axios</li><li>sass</li><li>js-cookie</li></ol><h3 id="开发工具："><a href="#开发工具：" class="headerlink" title="开发工具："></a>开发工具：</h3><ol><li>VSCode</li><li>Vetur</li><li>ESLint</li><li>Git</li><li>Sass</li><li>Nginx</li></ol><h3 id="项目流程安排："><a href="#项目流程安排：" class="headerlink" title="项目流程安排："></a>项目流程安排：</h3><ol><li><a href="">基础架构拆解</a></li><li><a href="">登录模块</a></li><li><a href="">主页模块</a></li><li><a href="">组织架构</a></li><li><a href="">角色管理</a></li><li><a href="">员工管理</a></li><li><a href="">员工详情</a></li><li><a href="">云储存</a></li><li><a href="">权限应用</a></li><li><a href="">上线部署</a></li></ol><h2 id="拉取基础模板"><a href="#拉取基础模板" class="headerlink" title="拉取基础模板"></a>拉取基础模板</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><ol><li><p>创建一个空目录</p></li><li><p>打开终端，输入以下<code>git命令</code>克隆仓库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/PanJiaChen/vue-admin-template.git heimahr<br></code></pre></td></tr></table></figure><p> <code>heimahr</code>代表克隆出来的仓库被放在heimahr目录内，如果不写克隆出来的仓库将被默认放在vue-admin-template目录内。完成之后出现heimahr目录，克隆成功</p></li><li><p>用VSCode打开克隆出来的heimahr项目</p></li></ol><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol><li><p>进入<code>package.json</code>文件，找到<code>&quot;core-js&quot;</code>配置，此时的版本号已经有点滞后了，将后面的版本号改为<code>3.25.5</code></p></li><li><p>输入<code>npm install</code>安装依赖</p></li></ol><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> dev<br></code></pre></td></tr></table></figure><h3 id="安装VSCode插件"><a href="#安装VSCode插件" class="headerlink" title="安装VSCode插件"></a>安装VSCode插件</h3><ol><li>Vetur</li><li>ESLint</li></ol><p>这俩插件可以提高开发效率和检查错误，不过不安装也无伤大雅</p><h2 id="项目目录以及入口文件介绍"><a href="#项目目录以及入口文件介绍" class="headerlink" title="项目目录以及入口文件介绍"></a>项目目录以及入口文件介绍</h2><h3 id="src源目录"><a href="#src源目录" class="headerlink" title="src源目录"></a>src源目录</h3><h4 id="api目录"><a href="#api目录" class="headerlink" title="api目录"></a>api目录</h4><p>api目录主要用来存放一下与<code>请求</code>相关的代码，比如登录请求。这样一来别的组件需要发送/接收请求直接引入使用相应方法就可以</p><h4 id="assets目录"><a href="#assets目录" class="headerlink" title="assets目录"></a>assets目录</h4><p>assets目录为静态资源目录，该目录主要用来存放一些图片资源，字体资源之类的资源文件</p><h4 id="components目录"><a href="#components目录" class="headerlink" title="components目录"></a>components目录</h4><p>components目录为组件目录，一般多数组件都能用到的公共组件会被放在此目录下</p><h4 id="icons目录"><a href="#icons目录" class="headerlink" title="icons目录"></a>icons目录</h4><p>icons目录就是一个小图标目录，里面都是用来存放小图标的，因为里面都是使用SVG所以没有放在assets目录下，并且里面还有关于自动引入小图标的代码</p><h4 id="layout目录"><a href="#layout目录" class="headerlink" title="layout目录"></a>layout目录</h4><p>layout目录为布局目录，与布局相关组件会放在layout目录下</p><h4 id="router目录"><a href="#router目录" class="headerlink" title="router目录"></a>router目录</h4><p>router目录是存放项目路由的目录，与路由相关的配置文件会被放在此目录下</p><h4 id="store目录"><a href="#store目录" class="headerlink" title="store目录"></a>store目录</h4><p>store目录是Vuex配置文件的存放位置，也就是状态管理工具管理的数据会放在里面</p><h4 id="styles目录"><a href="#styles目录" class="headerlink" title="styles目录"></a>styles目录</h4><p>styles目录就是样式目录，里面都是一些公共样式</p><h4 id="utils目录"><a href="#utils目录" class="headerlink" title="utils目录"></a>utils目录</h4><p>utils目录为工具目录，里面都是一些工具文件，这些工具文件完成某些特定功能，别的地方需要使用这些功能，直接引入使用即可</p><h4 id="views目录"><a href="#views目录" class="headerlink" title="views目录"></a>views目录</h4><p>views目录也是一个组件目录，只不过里面存放的都是路由器组件，也就是路由需要使用到的组件</p><h4 id="main-js文件"><a href="#main-js文件" class="headerlink" title="main.js文件"></a>main.js文件</h4><p>main.js文件为项目的入口文件，该文件引入了一些其他文件，并且实例化了<code>Vue</code>，挂载了router，Vuex状态管理工具以及渲染app.vue根组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入一些外部文件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;normalize.css/normalize.css&#x27;</span> <span class="hljs-comment">// A modern alternative to CSS resets</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="hljs-keyword">import</span> locale <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui/lib/locale/lang/en&#x27;</span> <span class="hljs-comment">// lang i18n</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/styles/index.scss&#x27;</span> <span class="hljs-comment">// global css</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/icons&#x27;</span> <span class="hljs-comment">// icon</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/permission&#x27;</span> <span class="hljs-comment">// permission control</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 判断如果当前处于production(生产环境)进行一下操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; mockXHR &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../mock&#x27;</span>)<br>  <span class="hljs-title function_">mockXHR</span>()<br>&#125;<br><br><span class="hljs-comment">// 注册ElementUI组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>, &#123; locale &#125;)<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 实例化</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  store,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="app-vue文件"><a href="#app-vue文件" class="headerlink" title="app.vue文件"></a>app.vue文件</h4><p>app.vue为项目的根组件</p><h4 id="settings-js文件"><a href="#settings-js文件" class="headerlink" title="settings.js文件"></a>settings.js文件</h4><p>settings.js为基础设置文件，包括网站标题，固定header，是否显示logo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><br>  <span class="hljs-comment">// 网站标题</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;人力资源后台管理系统&#x27;</span>,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@type</span> &#123;<span class="hljs-type">boolean</span>&#125; true | false</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@description</span> Whether fix the header</span><br><span class="hljs-comment">   * 头部菜单栏是否固定</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">fixedHeader</span>: <span class="hljs-literal">false</span>,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@type</span> &#123;<span class="hljs-type">boolean</span>&#125; true | false</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@description</span> Whether show the logo in sidebar</span><br><span class="hljs-comment">   * 侧边栏是否显示logo</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">sidebarLogo</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="permission-js文件"><a href="#permission-js文件" class="headerlink" title="permission.js文件"></a>permission.js文件</h4><p>permission.js为路由守卫文件，里面有一个<code>路由前置守卫</code>(路由跳转之前执行)与一个<code>路由后置守卫</code>(路由跳转之后执行)</p><h2 id="Vuex结构介绍"><a href="#Vuex结构介绍" class="headerlink" title="Vuex结构介绍"></a>Vuex结构介绍</h2><p>模板中Vuex(状态管理工具)的设计思想：</p><ol><li>页面交互状态使用全局状态Vuex</li><li>根据功能拆分为不同模块(modules)进行状态管理</li><li>通过getters建立对于模板中属性的快捷访问</li></ol><p><img src="https://pic1.imgdb.cn/item/6825b87558cb8da5c8f3959a.png" alt="Vuex结构介绍"></p><h2 id="使用模板中的icon图标"><a href="#使用模板中的icon图标" class="headerlink" title="使用模板中的icon图标"></a>使用模板中的icon图标</h2>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java进阶】 多线程(上)</title>
      <link href="/2025/05/14/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%8A)/"/>
      <url>/2025/05/14/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是多线程？"><a href="#什么是多线程？" class="headerlink" title="什么是多线程？"></a>什么是多线程？</h2><ol><li>进程：每个进程之间拥有自己的一整套变量，一个进程可以包含多个线程，进程之间互不影响，如：QQ是一个进程，微信是一个进程，相互之间互不影响</li><li>线程：线程属于进程，多个线程会有共享数据的情况，也就是多个线程会共享同一块内存区域</li><li>并发：多线程就是并发的例子，一块CPU调度时会分为多个时间片，每个时间片内调度一个线程，这样就可以提高CPU的利用率。因为对于类似IO这种操作，CPU调度了，IO便干活，但CPU却闲下来了，为了提高CPU利用率，可以让他去干别的活。只不过由于时间片特别短，所以看上去每个线程像是同时工作一样。在同一时刻，有多个指令在单个CPU上<code>交替</code>执行</li><li>并行：类似于使用多块CPU一起工作，它不会分时间片调度，而是真正的同时工作，在同一时刻，有多个指令在多个CPU上<code>同时</code>执行(2核4线程CPU)</li></ol><blockquote><p>对于类似IO这种慢操作，可以开多个线程出来，尽量不要让CPU空闲下来，提高系统的资源利用率。但也不是说线程开的越多，资源利用率就越好的，执行IO相关的慢操作，线程可以适当多一些，因为很多时候CPU是空闲的，但如果是计算型操作，CPU不空闲的情况下，依然开很多线程，不仅不会提高资源利用率，反而会达到反效果，因为线程切换也是需要耗费资源的。</p></blockquote><h3 id="进程和线程的区别："><a href="#进程和线程的区别：" class="headerlink" title="进程和线程的区别："></a>进程和线程的区别：</h3><ol><li>资源管理：每个进程有独立的资源，线程共享所属进程的资源</li><li>通信方式：进程间通信需要通过<code>IPC机制</code>，线程间通信直接访问共享内存即可</li><li>开销：进程创建和切换开销大，线程创建和切换开销较小</li><li>并发能力：线程支持更好的并发执行</li><li>安全性：进程提供更好的隔离和安全性</li><li>定义：进程是系统分配资源的最小单位，线程是系统调度的最小单位</li></ol><h2 id="多线程的实现方式："><a href="#多线程的实现方式：" class="headerlink" title="多线程的实现方式："></a>多线程的实现方式：</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><ol><li>定义一个类，继承Thread类</li><li>重写run方法</li><li>创建子类对象，并启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建一个类并且继承Thread</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 2. 重写run方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 3. 创建对象 (该对象就是一条线程) 并且开启线程(调用start方法)</span><br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">td</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>();<br>        td.start();<br>        <br>        <span class="hljs-comment">// 输出100此&quot;hello&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试线程的并发机制"><a href="#测试线程的并发机制" class="headerlink" title="测试线程的并发机制"></a>测试线程的并发机制</h4><ol><li>沿用以上的代码接着开启一条线程td2</li><li>用线程对象调用<code>setName()</code>方法，给线程设置名字</li><li>在打印时，通过线程对象调用<code>getName()</code>方法获取当前执行的线程名字，就可以知道当前是哪一条线程在执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建一个类并且继承Thread</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 2. 重写run方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 3. 创建对象 (该对象就是一条线程) 并且开启线程(调用start方法)</span><br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">td</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>();<br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">td2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>();<br><br>        <span class="hljs-comment">// 给线程取名字</span><br>        td.setName(<span class="hljs-string">&quot;Thread-1&quot;</span>);<br>        td2.setName(<span class="hljs-string">&quot;Thread-2&quot;</span>);<br><br>        td.start();<br>        td2.start();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * Thread-1hello与Thread-2hello交替输出</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><ol><li>创建一个类，实现Runnable接口</li><li>重写run方法</li><li>在入口函数中，创建实现Runnable接口的类对象</li><li>创建Thread线程对象，并且把<code>Runnable接口的类对象</code>作为参数传递进构造函数中</li><li>开启线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 实现Runnable接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 2. 重写run方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Run&quot;</span>);<br><br>        <span class="hljs-comment">// 这里不能使用this.getNmae获取线程对象,this指向RunnableDemo对象,而不是线程对象</span><br>        <span class="hljs-comment">// 需要调用Thread.currentThread()获取当前线程对象,哪条线程执行的这个方法,获取的就是哪个线程对象</span><br>        System.out.println(Thread.currentThread().getName());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 3. 创建RunnableDemo类对象,表示多线程要执行的任务</span><br>        <span class="hljs-type">RunnableDemo</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableDemo</span>();<br><br>        <span class="hljs-comment">// 4. 创建Thread线程对象,并且传递RunnableDemo类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">td</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(rd);<br><br>        <span class="hljs-comment">// 设置名字</span><br>        td.setName(<span class="hljs-string">&quot;Thread-1&quot;</span>);<br><br>        <span class="hljs-comment">// 开启线程</span><br>        td.start();<br><br>        <span class="hljs-comment">// 输出run</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>通过实现Runnable接口的方法时，不能在run方法内使用<code>this</code>关键字来获取线程对象，而是需要使用<code>Thread.currentThread()</code>方法来获取线程对象，它代表哪条线程执行的这个方法,获取的就是哪个线程对象。</p><h3 id="通过Callable接口和Future接口方式实现"><a href="#通过Callable接口和Future接口方式实现" class="headerlink" title="通过Callable接口和Future接口方式实现"></a>通过Callable接口和Future接口方式实现</h3><p><strong>这种方式在书写方面会比之前麻烦，但是它可以获取<code>多线程运行的结果</code></strong></p><ol><li>创建一个CallableDemo类，实现Callable接口(Callable接口需要传递一个泛型,泛型类型就是多线程运行结果返回值类型)</li><li>重写抽象方法call()，call方法是有返回值的,返回值就是多线程运行结果(返回值类型与Callable接口传递的泛型类型保持一致)</li><li>创建CallableDemo类对象(表示多线程要执行的任务)</li><li>创建FutureTask(Future的实现类)对象(管理多线程运行的结果)</li><li>创建Thread对象(表示线程)，并且传入FutureTask对象作为参数，启动</li><li>通过FutureTask对象调用<code>get()</code>方法获取线程运行结果即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><br><span class="hljs-comment">// 1. 创建一个CallableDemo类，实现Callable接口</span><br><span class="hljs-comment">// Callable接口需要传递一个泛型,泛型类型就是多线程运行结果返回值类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-comment">// 2. 重写抽象方法call()，call方法是有返回值的,返回值就是多线程运行结果</span><br>    <span class="hljs-comment">// 返回值类型与Callable接口传递的泛型类型保持一致</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">997</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 3. 创建CallableDemo对象</span><br>        <span class="hljs-type">CallableDemo</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableDemo</span>();<br><br>        <span class="hljs-comment">// 4. 创建FutuerTask对象</span><br>        <span class="hljs-type">FutureTask</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(cd);<br><br>        <span class="hljs-comment">// 5. 创建线程对象,并且启动</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">td</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ft);<br>        td.start();<br><br>        <span class="hljs-comment">// 获取运行结果 997</span><br>        System.out.println(ft.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三种实现方法对比"><a href="#三种实现方法对比" class="headerlink" title="三种实现方法对比"></a>三种实现方法对比</h3><div class="table-container"><table><thead><tr><th>实现方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread</td><td>编程简单，可以直接使用Thread中的方法</td><td>可拓展性差，不能继续继承其他类</td></tr><tr><td>实现Runnable接口</td><td>拓展性强，还可以继承其他类</td><td>编程相对复杂，不能使用Thread中的方法</td></tr><tr><td>实现Callable接口</td><td>拓展性强，还可以继承其他类，<code>并且可以获取线程运行结果</code></td><td>编程相对复杂，不能使用Thread中的方法</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript箭头函数与this关键字</title>
      <link href="/2025/05/14/JavaScript/JavaScript%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8Ethis%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2025/05/14/JavaScript/JavaScript%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8Ethis%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this是JS中的一个特殊关键字，它在函数执行时自动定义，指向当前执行的上下文对象。不同于其他语言，JS中的this不一定是指向函数所在的对象，这取决于函数的调用方式</p><h3 id="this的基本概念"><a href="#this的基本概念" class="headerlink" title="this的基本概念"></a>this的基本概念</h3><p>this是一个在运行时进行绑定的引用，它的值取决函数的执行环境：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// Window</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// Window</span><br>&#125;<br><br><span class="hljs-title function_">fun</span>()<br></code></pre></td></tr></table></figure><ol><li>在浏览器环境下，全局环境中this指向<code>Window</code>对象<ol><li>在非严格模式下，<code>函数内</code>的this指向Window对象</li><li>在<code>严格模式</code>下，函数内的this指向undefined</li></ol></li><li>在NodeJs环境下，全局环境中this指向<code>global</code>对象</li></ol><h3 id="this的作用"><a href="#this的作用" class="headerlink" title="this的作用"></a>this的作用</h3><p>this的作用是让方法可以使用其所属对象的其他属性与方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>    name : <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello,我是&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><br>person.<span class="hljs-title function_">sayHello</span>()<br></code></pre></td></tr></table></figure><h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><p>this的值取决于函数的调用方式，而不是函数的定义方法</p><h4 id="全局上下文中"><a href="#全局上下文中" class="headerlink" title="全局上下文中"></a>全局上下文中</h4><p>全局执行上下文中(任何函数之外)，this指向全局对象</p><ol><li>浏览器中：this -&gt; window</li><li>NodeJs中：this -&gt; global</li></ol><h4 id="函数上下文中"><a href="#函数上下文中" class="headerlink" title="函数上下文中"></a>函数上下文中</h4><p>在函数内部，this指向的值取决于函数的调用方式(一般情况下，谁调用就指向谁)：</p><h5 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h5><p>普通函数(普通函数默认是Window调用)中，this指向全局对象(浏览器中是Window)，严格模式下是undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">normalFun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">strictFun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 开启严格模式</span><br>    <span class="hljs-string">&#x27;use strict&#x27;</span> <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-title function_">normalFun</span>() <span class="hljs-comment">// 输出 Window</span><br><span class="hljs-title function_">strictFun</span>() <span class="hljs-comment">// 输出 undefined</span><br></code></pre></td></tr></table></figure><h5 id="对象方法中的this"><a href="#对象方法中的this" class="headerlink" title="对象方法中的this"></a>对象方法中的this</h5><p>当函数作为对象的方法调用时，this指向调用该方法的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;javascript&#x27;</span>,<br>    <span class="hljs-attr">print</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><br>obj.<span class="hljs-title function_">print</span>() <span class="hljs-comment">// 打印 javascript</span><br><br><span class="hljs-comment">// 方法引用 - this会丢失原始上下文</span><br><span class="hljs-keyword">const</span> printFun = obj.<span class="hljs-property">print</span>;<br><span class="hljs-title function_">printFun</span>() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h5 id="构造函数中的this"><a href="#构造函数中的this" class="headerlink" title="构造函数中的this"></a>构造函数中的this</h5><p>当使用new关键字调用函数时，this指向新创建的实例对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>)<br>person.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">// 张三</span><br><br><span class="hljs-comment">// 如果忘记使用new , 没有返回值并且this指向window</span><br><span class="hljs-keyword">const</span> person2 = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;李四&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Window</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">// 李四</span><br></code></pre></td></tr></table></figure><h5 id="事件处理函数中的this"><a href="#事件处理函数中的this" class="headerlink" title="事件处理函数中的this"></a>事件处理函数中的this</h5><p>在DOM事件处理程序中，this一般指向触发事件的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myButton&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 输出: button元素</span><br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="内联事件处理中的this"><a href="#内联事件处理中的this" class="headerlink" title="内联事件处理中的this"></a>内联事件处理中的this</h5><p>在HTML属性中定义的事件处理程序，this指向所属的DOM元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(this)&quot;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h5><p>箭头函数中，不会创建自己的this，而是继承外部作用域的this值</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript异步处理Promise和Async</title>
      <link href="/2025/05/13/JavaScript/JavaScript%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86Promise%E5%92%8CAsync/"/>
      <url>/2025/05/13/JavaScript/JavaScript%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86Promise%E5%92%8CAsync/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript异步"><a href="#JavaScript异步" class="headerlink" title="JavaScript异步"></a>JavaScript异步</h2><blockquote><p>异步与同步是指在运行代码的过程中碰见了需要等待的代码，比如：计时器。此时同步运行会等待计时器执行完毕以后才会执行后面的代码，这会大大增加代码的执行时间。有时我们想要在程序遇见需要等待的代码时，先执行后面的代码，等待结束之后在回来执行相应的代码，这就是异步。</p></blockquote><h3 id="什么是异步？"><a href="#什么是异步？" class="headerlink" title="什么是异步？"></a>什么是异步？</h3><ol><li>同步：代码一行一行执行，之前的代码没有执行完，就不会执行后面的代码</li><li>异步：代码跳过等待部分，先执行后面的，在回来处理</li></ol><h3 id="常见异步条件"><a href="#常见异步条件" class="headerlink" title="常见异步条件"></a>常见异步条件</h3><ol><li>读写文件</li><li>计时器(setTimeout)</li><li>网络请求(fetch)</li><li>服务器请求数据</li></ol><p><strong>这些事件需要使用JavaScript提供的异步处理机制，否则页面会卡住，用户体验很差</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;,<span class="hljs-number">1000</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 输出顺序 1 3 2</span><br></code></pre></td></tr></table></figure><h3 id="回调函数地狱-callback-hell-问题"><a href="#回调函数地狱-callback-hell-问题" class="headerlink" title="回调函数地狱(callback hell)问题"></a>回调函数地狱(callback hell)问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">fun</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;计时器完毕&#x27;</span>)<br>        <span class="hljs-title function_">fun</span>();<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><br><span class="hljs-title function_">demo</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;回调函数地狱&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>回调函数嵌套太多可读性太差，会触发回调函数地狱(callback hell)问题，使用Promise可以有效的解决回调函数地狱问题</strong></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>Promise是JavaScript中为异步编程提供的一种解决方案，它代表一个将来才会结束的操作，操作的结果可能成功，也可能失败。Promise是一个装着将来操作结果的盒子，盒子打开之前，无法知道里面的结果是成功或者失败。</p></blockquote><h3 id="Promise-的三种状态"><a href="#Promise-的三种状态" class="headerlink" title="Promise 的三种状态"></a>Promise 的三种状态</h3><div class="table-container"><table><thead><tr><th>状态</th><th>结果</th></tr></thead><tbody><tr><td>pending</td><td>等待中，初始状态</td></tr><tr><td>fulfilled</td><td>已完成，操作成功，得到结果</td></tr><tr><td>rejected</td><td>已拒绝，操作失败，返回错误</td></tr></tbody></table></div><blockquote><p>Promise创建后为pending状态，获得结果之后，切换为fulfilled/rejected状态，状态变为fulfilled/rejected就不能再切换了。</p></blockquote><h3 id="Promsie基本使用"><a href="#Promsie基本使用" class="headerlink" title="Promsie基本使用"></a>Promsie基本使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pro = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">// 异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(success)&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;操作成功&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;操作失败&quot;</span>)<br>        &#125;<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;)<br><br><span class="hljs-comment">// 使用.then 与 .catch 处理回调</span><br>pro.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;操作成功&#x27;</span>)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;操作失败&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><ol><li>resolve(value)：代表成功，返回数据</li><li>reject(err)：代表失败，返回错误</li><li>.then()：处理成功回调</li><li>.catch()：处理失败回调</li></ol><h3 id="Promise中的静态方法"><a href="#Promise中的静态方法" class="headerlink" title="Promise中的静态方法"></a>Promise中的静态方法</h3><div class="table-container"><table><thead><tr><th>静态方法</th><th>使用</th></tr></thead><tbody><tr><td>Promise.resolve(value)</td><td>快速创建一个成功状态的Promise</td></tr><tr><td>Promise.reject(err)</td><td>快速创建一个失败状态的Promise</td></tr><tr><td>Promise.all([])</td><td>多个Promise，全部成功才算成功</td></tr><tr><td>Promise.race([])</td><td>哪个Promise先完成，就使用对应的Promise结果</td></tr></tbody></table></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">true</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">true</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">true</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">true</span>),<br>    <span class="hljs-comment">// 有一个为false 就会进入catch</span><br>])<br></code></pre></td></tr></table></figure><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><blockquote><p>async和await是Promise的语法糖，它是对Promise更清晰的写法，本质还是Promise。</p></blockquote><ol><li>async：声明一个函数为异步函数</li><li>await：只能在异步函数内使用，代表等待Promise执行完以后才继续执行</li></ol><h3 id="使用async声明一个异步函数"><a href="#使用async声明一个异步函数" class="headerlink" title="使用async声明一个异步函数"></a>使用async声明一个异步函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>async函数一定返回一个Promise对象</strong></p><h3 id="使用await等待Promise结果"><a href="#使用await等待Promise结果" class="headerlink" title="使用await等待Promise结果"></a>使用await等待Promise结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1000毫秒之后&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">ms</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">1000</span>))<br>&#125;<br><br><span class="hljs-title function_">hello</span>()<br><br><span class="hljs-comment">// 执行顺序是 输出hello -&gt; 等待1000毫秒 -&gt; 输出1000毫秒之后 </span><br><span class="hljs-comment">// await会等待delay函数执行完毕后才继续执行后面的代码</span><br></code></pre></td></tr></table></figure><ol><li>函数前的关键字<code>await</code>会等待Promise结果</li><li>await只能在<code>async</code>函数中使用</li></ol><h3 id="错误处理try…catch…"><a href="#错误处理try…catch…" class="headerlink" title="错误处理try…catch…"></a>错误处理try…catch…</h3><blockquote><p>在<code>await</code>等待过程中，如果Promise被reject，就会抛出异常，有时我们需要通过try…catch…将其包裹防止程序崩溃。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1000毫秒之后&#x27;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise出错&#x27;</span> + err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="async与await常见问题"><a href="#async与await常见问题" class="headerlink" title="async与await常见问题"></a>async与await常见问题</h3><div class="table-container"><table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td>await外面不能使用</td><td>await只能写在async修饰的函数内</td></tr><tr><td>忘记try…catch…</td><td>一旦出错，整个程序将会崩溃</td></tr><tr><td>不会自动等待多个异常</td><td>需要Promise.all([])并发等待</td></tr><tr><td>async默认返回Promise</td><td>不是立即返回，而是承诺返回</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java进阶】 IO体系中的各种高级流</title>
      <link href="/2025/05/12/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91%20IO%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%AB%98%E7%BA%A7%E6%B5%81/"/>
      <url>/2025/05/12/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91%20IO%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%AB%98%E7%BA%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p><img src="https://pic1.imgdb.cn/item/6821ff7158cb8da5c8eeb231.png" alt="缓冲流"></p><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>原理： 底层自带了长度为<code>8192</code>(字节)的缓冲区提高性能</p><div class="table-container"><table><thead><tr><th>构造器</th><th>使用</th></tr></thead><tbody><tr><td>public BufferedInputStream(InputStream is)</td><td>把基本流<code>包装</code>成高级流，提高<code>读取数据</code>的性能</td></tr><tr><td>public BufferedOutputStream(OutputStream os)</td><td>把基本流<code>包装</code>成高级流，提高<code>写出数据</code>的性能</td></tr></tbody></table></div><h4 id="单字节拷贝"><a href="#单字节拷贝" class="headerlink" title="单字节拷贝"></a>单字节拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedInputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建 BufferedInputStream 读取数据对象</span><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>));<br>        <span class="hljs-comment">// 创建 BufferedOutputStream 写出数据对象</span><br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copyIO.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">while</span>((b = bis.read()) != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 写入数据</span><br>            bos.write(b);<br>        &#125;<br><br>        bos.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多字节拷贝"><a href="#多字节拷贝" class="headerlink" title="多字节拷贝"></a>多字节拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedInputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建 BufferedInputStream 读取数据对象</span><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>));<br>        <span class="hljs-comment">// 创建 BufferedOutputStream 写出数据对象</span><br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copyIO.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">while</span>((b = bis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 写入数据</span><br>            bos.write(bytes,<span class="hljs-number">0</span>,b);<br>        &#125;<br><br>        bos.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字节缓冲流读写原理"><a href="#字节缓冲流读写原理" class="headerlink" title="字节缓冲流读写原理"></a>字节缓冲流读写原理</h4><p><img src="https://pic1.imgdb.cn/item/6821ff7258cb8da5c8eeb23b.png" alt="字节缓冲流读写原理"></p><ol><li>基本流读取数据放在缓冲区中，一次性读取8192个字节</li><li>变量b在内存中不断将左边缓冲区中的数据一个一个的放入右边的缓冲区中</li><li>右边缓冲区装满时，自动写入到目标文件</li></ol><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><div class="table-container"><table><thead><tr><th>构造器</th><th>使用</th></tr></thead><tbody><tr><td>public BufferedReader(Reader r)</td><td>把基本流包装为高级流</td></tr><tr><td>public BufferedWriter(Writer r)</td><td>把基本流包装为高级流</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>特有方法</th><th>使用</th></tr></thead><tbody><tr><td>public String readLine()</td><td>读取一行数据，如果没有数据可读，返回null</td></tr><tr><td>public void newLine()</td><td>跨平台的换行</td></tr></tbody></table></div><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>转换流是字符流和字节流之间的桥梁</p><p>作用: </p><pre><code class="hljs">1. 指定字符集进行读写数据（JDK11之后淘汰）2. 字节流想要使用字符流的方法</code></pre><hr><h3 id="指定字母编码格式读取数据"><a href="#指定字母编码格式读取数据" class="headerlink" title="指定字母编码格式读取数据"></a>指定字母编码格式读取数据</h3><ol><li><p>JDK11之前</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建对象并指定字符编码</span><br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>), <span class="hljs-string">&quot;GBK&quot;</span>);<br><br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-type">int</span> ch;<br><span class="hljs-keyword">while</span>((ch = isr.read()) != -<span class="hljs-number">1</span>)&#123;<br>    System.out.print((<span class="hljs-type">char</span>)ch);<br>&#125;<br><br><span class="hljs-comment">// 释放资源</span><br>isr.close();<br></code></pre></td></tr></table></figure></li><li><p>JDK11之后</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建对象并指定字符编码</span><br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>,Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>));<br><br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-type">int</span> ch;<br><span class="hljs-keyword">while</span>((ch = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>    System.out.print((<span class="hljs-type">char</span>)ch);<br>&#125;<br><br><span class="hljs-comment">// 释放资源</span><br>fr.close();<br></code></pre></td></tr></table></figure></li></ol><h3 id="指定字符编码格式写出数据"><a href="#指定字符编码格式写出数据" class="headerlink" title="指定字符编码格式写出数据"></a>指定字符编码格式写出数据</h3><ol><li><p>JDK11之前</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建转换流对象</span><br><span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>),<span class="hljs-string">&quot;GBK&quot;</span>);<br><br><span class="hljs-comment">// 写出数据</span><br>osw.write(<span class="hljs-string">&quot;神不惧死亡&quot;</span>);<br><br><span class="hljs-comment">// 释放资源</span><br>osw.close();<br></code></pre></td></tr></table></figure></li><li><p>JDK11之后</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 直接创建FileWriter对象</span><br><span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>,Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>));<br><br><span class="hljs-comment">// 写入数据</span><br>fw.write(<span class="hljs-string">&quot;神不惧死亡&quot;</span>);<br><br><span class="hljs-comment">// 释放资源</span><br>fw.close();<br></code></pre></td></tr></table></figure></li></ol><h3 id="将本地GBK文件转为UTF-8文件"><a href="#将本地GBK文件转为UTF-8文件" class="headerlink" title="将本地GBK文件转为UTF-8文件"></a>将本地GBK文件转为UTF-8文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建读取对象</span><br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>,Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>));<br>        <span class="hljs-comment">// 创建写入对象</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;IOUTF.txt&quot;</span>,Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br><br>        <span class="hljs-comment">// 读取数据</span><br>        <span class="hljs-type">int</span> ch;<br>        <span class="hljs-keyword">while</span>((ch = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 写入数据</span><br>            fw.write((<span class="hljs-type">char</span>)ch);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭资源 - 先开的后关</span><br>        fw.close();<br>        fr.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="序列化流与反序列化流"><a href="#序列化流与反序列化流" class="headerlink" title="序列化流与反序列化流"></a>序列化流与反序列化流</h2><blockquote><p><code>序列化流</code>可以将Java中的<code>对象类型数据</code>写入到本地文件之中，写入之后是看不懂的一堆乱码(类似于：��srStudent/�l�_�QIageLnametLjava/lang/String;xptzhangsan)。但是可以使用<code>反序列化流</code>读取出来，读取出来以后就是正常对象类型数据。读取出来后，类型默认为Object类型，如果需要的是其他自定义的对象类型，可以使用<code>强制类型转换</code>，将数据转换为其他类型。</p></blockquote><h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p><strong>将程序中的对象，写入到文件中</strong></p><div class="table-container"><table><thead><tr><th>构造器</th><th>使用</th></tr></thead><tbody><tr><td>public ObjectOutputStream(OutputStream out)</td><td>把基本流包装为高级流</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>成员方法</th><th>使用</th></tr></thead><tbody><tr><td>public final void writeObject(Obejct obj)</td><td>把对象序列化(写出)到文件中</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建要写出到文件中的对象</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">21</span>);<br><br><span class="hljs-comment">// 创建序列化流对象</span><br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>));<br><br><span class="hljs-comment">// 写出对象数据</span><br>oos.writeObject(stu);<br><br><span class="hljs-comment">// 释放资源</span><br>oos.close();<br></code></pre></td></tr></table></figure><blockquote><p>注意：在利用序列化流写出数据时，里面会出现<code>NotSerializableException</code>异常。解决方法是：让对应对象类型的Javabean类(我这边创建的是Student类)实现一个<code>Serializable接口</code>(Serializable接口：里面没有任何抽象方法，为<code>标记型接口</code>，一旦实现这个接口表示当前的javabean类可以被序列化)。</p></blockquote><h3 id="反序列化流"><a href="#反序列化流" class="headerlink" title="反序列化流"></a>反序列化流</h3><p><strong>将文件中的对象，读取到程序中</strong></p><div class="table-container"><table><thead><tr><th>构造器</th><th>使用</th></tr></thead><tbody><tr><td>public ObjectInputStream(InputStream)</td><td>把基本流包装为高级流</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>成员方法</th><th>使用</th></tr></thead><tbody><tr><td>public Object readObject()</td><td>将序列化到本地中的对象，读取到程序中</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建反序列化对象</span><br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>));<br><br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student)ois.readObject();<br><br><span class="hljs-comment">// 打印</span><br>System.out.println(s);<br><br><span class="hljs-comment">// 释放资源</span><br>ois.close();<br></code></pre></td></tr></table></figure><hr><blockquote><p>问题：假设：我们已经使用序列化流将对象写入到本地文件中，但是又在后续对javabean类做了修改，比如添加了一个属性，此时如果我们使用反序列化流从本地文件中读取对象时会发现，程序出现报错。</p><p>原因：如果一个类实现了Serializable接口，那么表示这个类是可被序列化的。此时java底层会根据这个类的所有内容(成员变量，构造方法，成员方法…)进行计算，计算出一个long类型的序列号(版本号)，假如此时计算出的版本号为0011，那么java会将0011版本号记录到本地文件中。如果此时修改javabean内的代码，会计算一个新的版本号，当我们读取本地对象时，两个版本号不一致，所以程序出现错误。</p><p>解决方案:在定义javabean类时定义一个固定的版本号。版本号为私有，不让外界使用，也不提供get,set方法。版本号的变量名一定要写成<code>serialVersionUID</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Serial</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0011L</span>;<br></code></pre></td></tr></table></figure><p><strong>如果一个对象中的某个变量的值不想被序列化，给该成员变量加上<code>transient</code>关键字修饰，表示该成员变量不参与序列化过程。</strong></p><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><blockquote><p>打印流不能读,只能写。打印流只有输出流</p></blockquote><ol><li>打印流只操作文件目的地，不操作数据源</li><li>特有的写出方法可以实现，数据原样写出</li><li>特有的写出方法可以实现，自动换行，自动刷新</li></ol><h3 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流"></a>字节打印流</h3><div class="table-container"><table><thead><tr><th>构造方法</th><th>使用</th></tr></thead><tbody><tr><td>public PrintStream(OutputStream/File/String)</td><td>关联字节输出流/文件/文件路径</td></tr><tr><td>public PrintStream(String fileName, Chatset charset)</td><td>指定字符编码</td></tr><tr><td>public PrintStream(OutputStream os, boolean autoFlush)</td><td>自动刷新</td></tr><tr><td>public PrintStream(OutputStream os, boolean autoFlush, String encoding)</td><td>指定字符编码且自动刷新</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>成员方法</th><th>使用</th></tr></thead><tbody><tr><td>public void write(int b)</td><td>常规方法：将指定字节写出</td></tr><tr><td>public void println(XXX xxx)</td><td>特有方法：打印任意数据，自动刷新换行</td></tr><tr><td>public void print(XXX xxx)</td><td>特有方法：打印任意数据，不换行</td></tr><tr><td>public void printf(String format, Object… args)</td><td>特有方法：带占位符的打印，不换行</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建字节打印流</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;io.txt&quot;</span>);<br><br><span class="hljs-comment">// 写出数据</span><br>ps.println(<span class="hljs-string">&quot;岂不闻光阴如骏马加鞭&quot;</span>);<br>ps.println(<span class="hljs-string">&quot;岁月如落花流水&quot;</span>);<br><br><span class="hljs-comment">// 释放资源</span><br>ps.close();<br></code></pre></td></tr></table></figure><h3 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流"></a>字符打印流</h3><p><strong>字符打印流与字节打印流构造方法与成员方法都是类似，只是底层多了一个缓冲区</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建字节打印流对象</span><br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-string">&quot;io.txt&quot;</span>);<br><br><span class="hljs-comment">// 写出数据</span><br>pw.println(<span class="hljs-string">&quot;岂不闻天无绝人之路&quot;</span>);<br>pw.println(<span class="hljs-string">&quot;只要我想走，路就在脚下&quot;</span>);<br><br><span class="hljs-comment">// 释放资源</span><br>pw.close();<br></code></pre></td></tr></table></figure><h3 id="输出语句与打印流之间的关系"><a href="#输出语句与打印流之间的关系" class="headerlink" title="输出语句与打印流之间的关系"></a>输出语句与打印流之间的关系</h3><blockquote><p>输出语句其实底层用的就是打印流。如果进入<code>System</code>类，可以看见，<code>out</code>是System中一个<code>PrintStream</code>类的静态变量，那么<code>System.out.peintln</code>，其实就是通过System类调用out静态变量，然后在调用PrintStream中的<code>println()</code>方法。out这个<code>打印流对象</code>，是在虚拟机启动时，由虚拟机自动创建的。out打印流对象默认指向控制台，也可以把它称为：<code>系统中的标准输出流</code>。</p></blockquote><h2 id="压缩流与解压缩流"><a href="#压缩流与解压缩流" class="headerlink" title="压缩流与解压缩流"></a>压缩流与解压缩流</h2><h3 id="解压缩流"><a href="#解压缩流" class="headerlink" title="解压缩流"></a>解压缩流</h3><p>压缩包里面的每一个文件都是一个<code>ZipEntry</code>对象，解压的本质就是把每一个ZipEntry对象按照层级拷贝到本地另一个文件夹中。在Java中只能识别<code>.zip</code>的压缩文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.util.zip.ZipEntry;<br><span class="hljs-keyword">import</span> java.util.zip.ZipInputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 定义一个File对象表示压缩包,数据源</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;IOUTF.zip&quot;</span>);<br>        <span class="hljs-comment">// 定义一个File对象表示解压文件的位置,目的地</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src&quot;</span>);<br><br>        unzip(src, dest);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义一个方法用来解压</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unzip</span><span class="hljs-params">(File src, File dest)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建一个解压缩流用来读取压缩包中的数据</span><br>        <span class="hljs-type">ZipInputStream</span> <span class="hljs-variable">zis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src));<br>        <span class="hljs-comment">// 获取压缩包中的每一个zipentry对象</span><br>        ZipEntry zipEntry;<br>        <span class="hljs-keyword">while</span> ((zipEntry = zis.getNextEntry()) != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (zipEntry.isDirectory()) &#123;<br>                <span class="hljs-comment">// 如果是文件夹</span><br>                <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dest, zipEntry.toString());<br>                file.mkdirs();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dest, zipEntry.toString()));<br>                <span class="hljs-comment">// 如果是文件</span><br>                <span class="hljs-type">int</span> b;<br>                <span class="hljs-keyword">while</span> ((b = zis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                    fos.write(b);<br>                &#125;<br>                fos.close();<br>                zis.closeEntry();<br>            &#125;<br>        &#125;<br>        zis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h3><p>压缩的本质：把每一个ZipEntry对象放到压缩包中</p><h4 id="压缩单个文件"><a href="#压缩单个文件" class="headerlink" title="压缩单个文件"></a>压缩单个文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.zip.ZipEntry;<br><span class="hljs-keyword">import</span> java.util.zip.ZipOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建File对象表示要压缩的文件</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;IOGDK.txt&quot;</span>);<br>        <span class="hljs-comment">// 创建File表示压缩到的位置</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src&quot;</span>);<br><br>        toZip(src, dest);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">toZip</span><span class="hljs-params">(File src, File dest)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">ZipOutputStream</span> <span class="hljs-variable">zos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dest,<span class="hljs-string">&quot;IOGBK.zip&quot;</span>)));<br><br>        <span class="hljs-type">ZipEntry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipEntry</span>(<span class="hljs-string">&quot;GBK.txt&quot;</span>);<br><br>        zos.putNextEntry(entry);<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">while</span>((b = fis.read()) != -<span class="hljs-number">1</span>)&#123;<br>            zos.write(b);<br>        &#125;<br>        fis.close();<br>        zos.closeEntry();<br>        zos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Commons-io工具包"><a href="#Commons-io工具包" class="headerlink" title="Commons-io工具包"></a>Commons-io工具包</h2><h3 id="第三方包使用步骤"><a href="#第三方包使用步骤" class="headerlink" title="第三方包使用步骤"></a>第三方包使用步骤</h3><ol><li>下载第三方Commons-io包:<a href="https://commons.apache.org/io/download_io.cgi">https://commons.apache.org/io/download_io.cgi</a></li><li>在项目中新建一个<code>lib</code>文件夹，用来专门存放第三方包</li><li>将<code>jar包</code>复制粘贴到lib文件夹</li><li>右键点击jar包，选择<code>Add as Library</code> -&gt; 点击OK</li></ol><p><a href="https://commons.apache.org/proper/commons-io/">Commons-io</a>是<code>apache</code>(专门为开源软件项目办的一个非营利性组织)开源基金组织提供的一组关于IO操作的开源工具包(还达不到框架级别)，可以提高IO流的开发效率。</p><h3 id="Commons-io常见方法"><a href="#Commons-io常见方法" class="headerlink" title="Commons-io常见方法"></a>Commons-io常见方法</h3><div class="table-container"><table><thead><tr><th>FileUtils类(文件/文件夹)</th><th>说明</th></tr></thead><tbody><tr><td>static void copyFile(File srcFile, File destFile)</td><td>复制文件</td></tr><tr><td>static void copyDirectory(File srcDir, File destDir)</td><td>复制文件夹</td></tr><tr><td>static void copyDirectoryToDirectory(File srcDir, File destDir)</td><td>复制文件夹</td></tr><tr><td>static void deleteDirectory(File directory)</td><td>删除文件夹</td></tr><tr><td>static void cleanDirectory(File directory)</td><td>清空文件夹</td></tr><tr><td>static String readFileToString(File file, Charset encoding)</td><td>读取文件中的数据为字符串</td></tr><tr><td>static void write(File file, CharSequence data, String encoding)</td><td>写出数据</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>IOUtils类(流相关)</th><th>说明</th></tr></thead><tbody><tr><td>public static int copy(InputStream input, OutputStream output)</td><td>复制文件</td></tr><tr><td>public static int copyLarge(Reader input, Writer output)</td><td>复制大文件</td></tr><tr><td>public static String readLines(Reader input)</td><td>读取数据</td></tr><tr><td>public static void write(String data, OutputStream output)</td><td>写出数据</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于计算机中的字符集</title>
      <link href="/2025/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
      <url>/2025/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<ol><li>计算机中, 任意数据以<code>二进制</code>形式存储</li><li>计算机中, 最小的存储单元为<code>一个字节</code></li><li>ASCll字符集中, 一个英文占一个字节</li><li>简体中文版Windows, 默认使用GBK字符集</li><li>GBK字符集完全兼容ASCll字符集</li></ol><h3 id="计算机存储规则"><a href="#计算机存储规则" class="headerlink" title="计算机存储规则"></a>计算机存储规则</h3><blockquote><p>计算机中,任意数据都是以<code>二进制</code>方式存储,一个0/1通常称为1<code>bit/比特位</code>。8个bit为一组,称为<code>字节</code>,字节是计算机中最小的存储单位。计算机存储英文,通常只需要一个字节。而汉字需要两个字节存储,这也是有时会出现乱码的原因。</p></blockquote><h3 id="ASCll-字符集"><a href="#ASCll-字符集" class="headerlink" title="ASCll 字符集"></a>ASCll 字符集</h3><blockquote><p>计算机存储英文时,会将要存储的英文拿到ASCll表中查询,获得对应的二进制数据,然后编码(ASCll的编码规则:前面补0,补齐8位,也就是一个字节),将编码之后的二进制存储到计算机中。反之则是解码,然后去ASCll获取对应的字符显示即可。</p></blockquote><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><blockquote><p>最早<code>GB2312字符集</code>,1980年发布,为简体中文汉字国家标准,其中包括6763个简体汉字(没有繁体)。台湾省用不了,所以对岸小朝廷就自己搞了一个<code>BIG5字符集</code>,收录13053个中文字。2000年,发布<code>GBK字符集</code>收录21003汉字,其中包含了GB13000-1中的中日韩汉字和BIG5编码中的所有汉字。windows系统默认使用的就是GBK。但是系统显示的是<code>ANSI</code>。</p></blockquote><ol><li>英文占一个字节,汉字占两个字节存储</li><li>高位字节二进制一定以1开头,转为十进制之后为负数</li></ol><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><blockquote><p>国际标准字符集,将世界各语言字符定义了一个唯一编码,以满足跨语言,跨平台,称为<code>万国码</code>。</p></blockquote><ol><li>存储英文</li></ol><p>Unicode也完全兼容ASCll表,但是编码的时候就要复杂一些</p><pre><code class="hljs">1. UTF-16编码规则: 用2-4个字节保存2. UTF-32编码规则: 固定使用四个字节保存3. UTF-8编码规则: 用1-4字节保存(常见)</code></pre><p>UTF-8规定,如果是ASCll中的<code>英文字母</code>,统一用一个字节保存。可如果是阿拉伯文,希腊语使用两个字节表示。如果是<code>中日韩</code>,中东文字,使用三个字节表示。其他一些语言使用四个字节表示。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java进阶】 IO流中的基础流</title>
      <link href="/2025/04/20/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91IO%E6%B5%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/04/20/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91IO%E6%B5%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是IO流"><a href="#什么是IO流" class="headerlink" title="什么是IO流?"></a>什么是IO流?</h2><p><strong>IO(Input &amp;&amp; Output)流是存储与读取数据的解决方案</strong>。</p><ol><li>把程序中的数据保存在文件中(写)</li><li>把文件中的数据加载到程序中(读)</li></ol><p>IO流的分类</p><ol><li>按照流的方向: 输入流(读取)与输出流(写入)</li><li>按照操作文件的类型: 字节流(所有类型文件,图片,视频,音频)与字符流(纯文本文件,.txt,.md,.xml)</li></ol><p>纯文本文件: 用Windows自带的记事本能<code>打开并且能读懂</code>的文件</p><h2 id="IO流体系"><a href="#IO流体系" class="headerlink" title="IO流体系"></a>IO流体系</h2><ol><li><p>字节流</p><ol><li>InputStream: 字节输入流</li><li>OutputStream: 字节输出流</li></ol></li><li><p>字符流</p><ol><li>Reader: 字符输入流</li><li>Write: 字符输出流</li></ol></li></ol><p>都是抽象类, 无法创建实例</p><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>操作本地文件的字节输出流,可以把程序中的数据写到本地文件中</p><ol><li>创建对象</li><li>写数据</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个字节输出流</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><span class="hljs-comment">// 1. 参数是字符串路径, 或者File对象都可以</span><br><span class="hljs-comment">// 2. 如果路径文件不存在, 会自动创建新文件, 但需要确保父级路径存在</span><br><span class="hljs-comment">// 3, 如果文件已经存在, 则会清空文件</span><br><br><span class="hljs-comment">// 写出数据</span><br>fos.write(<span class="hljs-number">97</span>);<br><span class="hljs-comment">// 1. write参数是整数, 但是实际写在文件中的是ASCLL表中对应的字符</span><br><br><span class="hljs-comment">// 释放资源</span><br>fos.close();<br><span class="hljs-comment">// 每次使用完流之后, 都需要释放资源</span><br><span class="hljs-comment">// 如果不释放资源, Java会一直占用资源, 相当于一直打开文件, 释放相当于关闭文件</span><br></code></pre></td></tr></table></figure><p>运行程序,IO.txt文件内已经写入了一个<code>a</code></p><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>void write(int b)</td><td>一次写一个字节数据</td></tr><tr><td>void write(byte[] b)</td><td>一次写一个字节数组数据</td></tr><tr><td>void write(byte[] b,int off,int len)</td><td>一次写一个字节数组的部分数据</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = &#123;<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>&#125;;<br><br><span class="hljs-comment">// 创建一个字节输出流</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><br><span class="hljs-comment">// 写出数据</span><br>fos.write(bytes);<br><br><span class="hljs-comment">// 释放资源</span><br>fos.close();<br></code></pre></td></tr></table></figure><h3 id="换行和续写"><a href="#换行和续写" class="headerlink" title="换行和续写"></a>换行和续写</h3><ol><li>getBytes方法</li></ol><blockquote><p>如果需要写入一个字符串可以使用<code>字符串.gteBytes()</code>,会将字符串转换为字符数组,返回值刚好是一个Byte类型的字符数组,可以当做write()方法的形参</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个字节输出流</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java,Python&quot;</span>;<br><br><span class="hljs-comment">// 写出数据</span><br>fos.write(str.getBytes());<br><br><span class="hljs-comment">// 释放资源</span><br>fos.close();<br></code></pre></td></tr></table></figure><ol><li>换行</li></ol><p>想要换行只需要在写出一个换行符就可以了</p><p>换行符: </p><pre><code class="hljs">1. Windows: \r\n2. Linux: \n3. Mac: \r在Windows操作系统中,Java进行了优化, 只需输入\r或\n都可以实现换行,因为Java会帮我们补全</code></pre><ol><li>续写</li></ol><p>创建对象时,传入第二个参数<code>append参数</code>,默认为false(关闭续写),传入true表示打开续写</p><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>字节输入流,从磁盘文件中读取字节数据到程序中</p><ol><li>创建输入流对象</li><li>读取数据</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> file.read();<br><br>file.close()<br></code></pre></td></tr></table></figure><ol><li><strong>如果读不到会返回-1</strong></li><li>如果文件不存在会报错</li></ol><h3 id="FileInputStream-循环读取"><a href="#FileInputStream-循环读取" class="headerlink" title="FileInputStream 循环读取"></a>FileInputStream 循环读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><br><span class="hljs-comment">// 循环读取</span><br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span> ((b = file.read()) != -<span class="hljs-number">1</span>) &#123;<br><br>    System.out.print((<span class="hljs-type">char</span>)b + <span class="hljs-string">&quot; &quot;</span>);<br><br>&#125;<br><br>file.close()<br></code></pre></td></tr></table></figure><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copyIO.txt&quot;</span>);<br><br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span> ((b = file.read()) != -<span class="hljs-number">1</span>) &#123;<br>    fos.write(b);<br>&#125;<br><br>fos.close();<br>file.close();<br></code></pre></td></tr></table></figure><p><strong>一次读写一个字节拷贝速度非常慢,只适用于拷贝小文件</strong></p><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>public int read()</td><td>一次读一字节</td></tr><tr><td>public int read(byte[] buffer)</td><td>一次读多字节</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copyIO.txt&quot;</span>);<br><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span> ((b = file.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 拷贝大文件,一次拷贝5MB</span><br>    fos.write(b);<br>&#125;<br><br>fos.close();<br>file.close();<br></code></pre></td></tr></table></figure><p>大文件拷贝可以使用长度为<code>1024*1024*5</code>的数组,也就是一次拷贝<code>5MB</code></p><h2 id="为什么会出现乱码"><a href="#为什么会出现乱码" class="headerlink" title="为什么会出现乱码?"></a>为什么会出现乱码?</h2><ol><li>读取数据时,未读完整个汉字</li><li>编码和解码方式不统一</li></ol><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><blockquote><p>字符流的底层就是一个字节流，只不过在字节流的基础上再加上字符集。特点是在读取数据时，一次读取一个字节，遇到中文时，一次读取多个字节。字符流非常适合操作纯文本文件，文本中有中文时，不会出现乱码。</p></blockquote><ol><li>Reader - 字符输入流</li><li>Write - 字符输出流</li></ol><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><ol><li>创建字符输入流对象</li><li>读取数据</li><li>释放资源</li></ol><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>public int read()</td><td>读取数据，读到结尾返回-1</td></tr><tr><td>public int read(char[] buffer)</td><td>读取多个数据，读到末尾返回-1</td></tr></tbody></table></div><ol><li>空参read()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建对象</span><br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><br><span class="hljs-comment">// 循环读取</span><br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span> ((b = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>    System.out.print((<span class="hljs-type">char</span>) b);<br>&#125;<br><br><span class="hljs-comment">// 释放资源</span><br>fileReader.close();<br></code></pre></td></tr></table></figure><ol><li>带参read()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建对象</span><br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><br><span class="hljs-comment">// 循环读取</span><br><span class="hljs-type">char</span>[] cha = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span> ((len = fileReader.read(cha)) != -<span class="hljs-number">1</span>) &#123;<br>    System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cha, <span class="hljs-number">0</span> , len));<br>&#125;<br><br><span class="hljs-comment">// 释放资源</span><br>fileReader.close();<br></code></pre></td></tr></table></figure><h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>public FileWriter(File file,boolean append)</td><td>创建字符输出流，append为续写开关可以省略，默认为false</td></tr><tr><td>public FileWriter(String pathname,boolean append)</td><td>创建字符输出流，append为续写开关可以省略</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建对象</span><br><span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;IO.txt&quot;</span>);<br><br><span class="hljs-comment">// 写入数据</span><br>fileWriter.write(<span class="hljs-string">&quot;Hello 世界&quot;</span>);<br><br><span class="hljs-comment">// 释放资源</span><br>fileWriter.close();<br></code></pre></td></tr></table></figure><p>write()可以传入string，int，char[]类型</p><hr><h2 id="字符流原理"><a href="#字符流原理" class="headerlink" title="字符流原理"></a>字符流原理</h2><ol><li><p>字符输入流</p><ol><li><p>创建字符输入流对象</p><ul><li>关联文件，并创建缓冲区（长度为8192的字节数组）</li></ul></li><li><p>读取数据</p><ul><li>判断缓冲区中是否有数据可以被读取</li><li>没有数据：从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区。如果文件中也没有剩余数据，返回-1</li><li>有数据：直接从缓冲区中读取数据</li></ul></li></ol></li><li><p>字符输出流</p></li></ol><blockquote><p>字符输出流会现将数据写入缓冲区中，缓冲区写满了才会写入到文件。如果想要直接写入文件可以通过<code>flush()</code>方法或者<code>close()</code>方法刷新或释放。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java进阶】 Stream流</title>
      <link href="/2025/04/16/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91Stream%E6%B5%81/"/>
      <url>/2025/04/16/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Stream流"><a href="#什么是Stream流" class="headerlink" title="什么是Stream流?"></a>什么是Stream流?</h2><p>Stream流就是对数据并像流水线一样<code>操作数据</code>。可以结合Lambda表达式,简化数组,集合的操作。</p><p>Stream流使用步骤:</p><pre><code class="hljs">1. 得到Stream流,并把数据放上去。2. 利用Stream流中的各种API进行数据的操作。</code></pre><h2 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h2><ol><li><p>单列集合获取Stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>);<br><span class="hljs-comment">// 获取stream流,并将数据放在stream流内,处理数据</span><br>list.stream().forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot; &quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>双列集合获取Stream流</p></li></ol><p>双列集合无法直接使用Stream流,需要用单列集合转换一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String, Integer&gt; hm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>hm.put(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-number">1</span>);<br>hm.put(<span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-number">2</span>);<br>hm.put(<span class="hljs-string">&quot;C#&quot;</span>, <span class="hljs-number">3</span>);<br>hm.put(<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-number">4</span>);<br><br><br><span class="hljs-comment">// 获取Stream流</span><br><span class="hljs-comment">// 拥有所有key的stream流</span><br>hm.keySet().stream().forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-comment">// 拥有每一个键值对的stream流</span><br>hm.entrySet().stream().forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;&quot;</span>));<br></code></pre></td></tr></table></figure><ol><li>数据获取stream流</li></ol><p>数组需要通过<code>Arrays类</code>来获取stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;;<br>Arrays.stream(arr).forEach(item -&gt; System.out.println(item));<br></code></pre></td></tr></table></figure><ol><li>一堆零散的数据</li></ol><p>这堆零散的数据需要是同种数据类型的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 直接通过Stream.of获取Stream流</span><br>Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).forEach(item -&gt; System.out.println(item));<br></code></pre></td></tr></table></figure><h2 id="Stream流的中间方法"><a href="#Stream流的中间方法" class="headerlink" title="Stream流的中间方法"></a>Stream流的中间方法</h2><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>filter(function)</td><td>过滤</td></tr><tr><td>limit(int num)</td><td>获取前几个元素</td></tr><tr><td>skip(int num)</td><td>跳过几个元素</td></tr><tr><td>distinct()</td><td>元素去重(依赖<code>hashCode,equals</code>方法,需要重写)</td></tr><tr><td>concat(Stream a, Stream b)</td><td>合并a,b两个流为一个流(两个流的数据类型,尽量保持一致)</td></tr><tr><td>map(new Function<T, R>(){})</td><td>转换流中的数据类型</td></tr></tbody></table></div><pre><code class="hljs">1. 中间方法返回新的Stream流,可以使用链式编程2. 修改Stream流中的数据,不会影响原来集合,数组中的数据</code></pre><ol><li>filter - 过滤</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java&quot;</span>,<span class="hljs-string">&quot;Html&quot;</span>,<span class="hljs-string">&quot;JavaScript&quot;</span>,<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;C#&quot;</span>,<span class="hljs-string">&quot;C++&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>);<br><span class="hljs-comment">// 过滤掉不是以&#x27;C&#x27;开头的数据</span><br>list.stream().filter(item -&gt; item.startsWith(<span class="hljs-string">&quot;C&quot;</span>));<br><span class="hljs-comment">// 输出 C# C++ C</span><br></code></pre></td></tr></table></figure><ol><li>limit - 获取前几个</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java&quot;</span>,<span class="hljs-string">&quot;Html&quot;</span>,<span class="hljs-string">&quot;JavaScript&quot;</span>,<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;C#&quot;</span>,<span class="hljs-string">&quot;C++&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>);<br><span class="hljs-comment">// 获取前三个元素</span><br>list.stream().limit(<span class="hljs-number">3</span>).forEach(item -&gt; System.out.println(item));<br><span class="hljs-comment">// 输出 Java Html JavaScript</span><br></code></pre></td></tr></table></figure><ol><li>skip - 跳过几个元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java&quot;</span>,<span class="hljs-string">&quot;Html&quot;</span>,<span class="hljs-string">&quot;JavaScript&quot;</span>,<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;C#&quot;</span>,<span class="hljs-string">&quot;C++&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-comment">// 跳过前三个元素</span><br>list.stream().skip(<span class="hljs-number">3</span>).forEach(item -&gt; System.out.println(item));<br><span class="hljs-comment">// 输出 Python C# C++ C</span><br></code></pre></td></tr></table></figure><ol><li>distinct - 元素去重</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java&quot;</span>,<span class="hljs-string">&quot;Html&quot;</span>,<span class="hljs-string">&quot;JavaScript&quot;</span>,<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;C#&quot;</span>,<span class="hljs-string">&quot;C++&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;Java&quot;</span>,<span class="hljs-string">&quot;Html&quot;</span>);<br><br><span class="hljs-comment">// 元素去重</span><br>list.stream().distinct().forEach(item -&gt;System.out.println(item));<br><span class="hljs-comment">// 输出 Java Html JavaScript Python C# C++ C</span><br></code></pre></td></tr></table></figure><p><strong>如果类型不是字符串类型,而是自定义的一些类型,需要重写<code>hashCode,equals</code>方法,因为String底层已经重写这两个方法了,所以这里我不需要重写</strong></p><ol><li>concat - 合并流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java&quot;</span>,<span class="hljs-string">&quot;Html&quot;</span>,<span class="hljs-string">&quot;JavaScript&quot;</span>,<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;C#&quot;</span>,<span class="hljs-string">&quot;C++&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>);<br>ArrayList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list2, <span class="hljs-string">&quot;CSS&quot;</span>,<span class="hljs-string">&quot;Vue&quot;</span>,<span class="hljs-string">&quot;Webpack&quot;</span>);<br><br><span class="hljs-comment">// 合并流</span><br>Stream.concat(list.stream(), list2.stream()).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-comment">// 输出 Java Html JavaScript Python C# C++ C CSS Vue Webpack</span><br></code></pre></td></tr></table></figure><ol><li>map - 转换数据流中的类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>Collections.addAll(list, <span class="hljs-string">&quot;Java-30&quot;</span>,<span class="hljs-string">&quot;Html-20&quot;</span>,<span class="hljs-string">&quot;JavaScript-18&quot;</span>,<span class="hljs-string">&quot;Python-15&quot;</span>,<span class="hljs-string">&quot;C#-13&quot;</span>,<span class="hljs-string">&quot;C++-33&quot;</span>,<span class="hljs-string">&quot;C-50&quot;</span>);<br><br><span class="hljs-comment">// 只获取后面的数字</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 泛型中第一个类型表示原本的类型,第二个类型表示转换之后的类型</span><br><span class="hljs-comment"> * 返回值类型表示转换之后的类型</span><br><span class="hljs-comment"> * s就代表原本的每一个数据</span><br><span class="hljs-comment"> * return 返回的是转换之后的数据</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 可以使用Lambda简写</span><br>list.stream().map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;String, Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-comment">// 通过&#x27;-&#x27;切割字符串</span><br>        String[] arr = s.split(<span class="hljs-string">&quot;-&quot;</span>);<br><br>        <span class="hljs-comment">// 获取数字</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 转换为Integer类型并且返回</span><br>        <span class="hljs-keyword">return</span> Integer.parseInt(age);<br>    &#125;<br>&#125;).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-comment">// 输出 30 20 18 15 13 33 50</span><br></code></pre></td></tr></table></figure><h2 id="Stream流的结束方法"><a href="#Stream流的结束方法" class="headerlink" title="Stream流的结束方法"></a>Stream流的结束方法</h2><p>结束方法,调用以后不能在调用其他方法了</p><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>forEach()</td><td>遍历</td></tr><tr><td>count()</td><td>统计</td></tr><tr><td>toArray()</td><td>收集数据,放在数组中</td></tr><tr><td>collect(Collector collector)</td><td>收集数据,放在集合中</td></tr></tbody></table></div><ol><li>forEach - 遍历</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java-30&quot;</span>,<span class="hljs-string">&quot;Html-20&quot;</span>,<span class="hljs-string">&quot;JavaScript-18&quot;</span>,<span class="hljs-string">&quot;Python-15&quot;</span>,<span class="hljs-string">&quot;C#-13&quot;</span>,<span class="hljs-string">&quot;C++-33&quot;</span>,<span class="hljs-string">&quot;C-50&quot;</span>);<br><br><span class="hljs-comment">// 遍历流中的数据</span><br>list.stream().forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-comment">// 输出 Java-30 Html-20 JavaScript-18 Python-15 C#-13 C++-33 C-50</span><br></code></pre></td></tr></table></figure><ol><li>count - 统计</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java-30&quot;</span>,<span class="hljs-string">&quot;Html-20&quot;</span>,<span class="hljs-string">&quot;JavaScript-18&quot;</span>,<span class="hljs-string">&quot;Python-15&quot;</span>,<span class="hljs-string">&quot;C#-13&quot;</span>,<span class="hljs-string">&quot;C++-33&quot;</span>,<span class="hljs-string">&quot;C-50&quot;</span>);<br><br><span class="hljs-comment">// 统计数据流中的数据,返回值为long类型</span><br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.stream().count();<br>System.out.println(count);<br><span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><ol><li>toArray() - 收集数据放入数组中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java-30&quot;</span>,<span class="hljs-string">&quot;Html-20&quot;</span>,<span class="hljs-string">&quot;JavaScript-18&quot;</span>,<span class="hljs-string">&quot;Python-15&quot;</span>,<span class="hljs-string">&quot;C#-13&quot;</span>,<span class="hljs-string">&quot;C++-33&quot;</span>,<span class="hljs-string">&quot;C-50&quot;</span>);<br><br><span class="hljs-comment">// 如果方法内不写参数,默认返回Object类型的数据</span><br>String[] arr = list.stream().toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntFunction</span>&lt;String[]&gt;() &#123;<br>    <span class="hljs-comment">// IntFunction泛型可以选择自己需要的类型,apply返回值的类型需要保持一致</span><br>    <span class="hljs-comment">// apply()中的形参表示流中数据的个数,要跟数组的长度保持一致</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] apply(<span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[value];<br>    &#125;<br>&#125;);<br><br>System.out.println(Arrays.toString(arr));<br></code></pre></td></tr></table></figure><pre><code class="hljs">参数的作用:负责创建指定类型的数组方法的底层:依次得到流中的每个数据,放在数组中方法的返回值:一个装着流里面所有数据的数组</code></pre><ol><li>collect - 收集数据,放入集合中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java-30&quot;</span>,<span class="hljs-string">&quot;Html-20&quot;</span>,<span class="hljs-string">&quot;JavaScript-18&quot;</span>,<span class="hljs-string">&quot;Python-15&quot;</span>,<span class="hljs-string">&quot;C#-13&quot;</span>,<span class="hljs-string">&quot;C++-33&quot;</span>,<span class="hljs-string">&quot;C-50&quot;</span>);<br><br><span class="hljs-comment">// 收集到List集合中</span><br>List&lt;String&gt; newList = list.stream().collect(Collectors.toList());<br>System.out.println(newList);<br><br><span class="hljs-comment">// 收集到Set集合中</span><br>Set&lt;String&gt; newSet = list.stream().collect(Collectors.toSet());<br>System.out.println(newSet);<br><br><span class="hljs-comment">// 收集到Map集合中 - 规定谁作为key,谁作为value</span><br><span class="hljs-comment">// toMap()方法内需要规定Key的规则,value的规则</span><br><span class="hljs-comment">// Function内的第一个泛型类型对应apply()方法的参数类型,第二个泛型类型对应apply()返回值类型</span><br><span class="hljs-comment">// new Function()也可以使用Lambda简写</span><br>Map&lt;String, Integer&gt; map = list.stream().collect(Collectors.toMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;String,String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(String t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;String,Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(String t)</span> &#123;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(t.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;));<br><br>System.out.println(map);<br></code></pre></td></tr></table></figure><p><strong>数据收集到Map集合中,key是不能重复的</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java进阶】 File，异常以及方法引用</title>
      <link href="/2025/04/12/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91File&amp;%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2025/04/12/Java/%E3%80%90Java%E8%BF%9B%E9%98%B6%E3%80%91File&amp;%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="文件路径表示方式"><a href="#文件路径表示方式" class="headerlink" title="文件路径表示方式"></a>文件路径表示方式</h2><ol><li>绝对路径: 基于某一盘符下的完整路径</li><li><p>相对路径: 相对于某一文件来说的相对路径</p><ul><li>使用单元测试方法: 相对于module来说</li><li>使用main()方法: 相对于project来说</li></ul></li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>使用构造函数传入一个文件/文件夹路径可以创建一个对应路径的文件/文件夹对象</p><ol><li>File(String pathname)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建文件对象</span><br><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\xiaohu\\Desktop\\Java.txt&quot;</span>);<br><br>System.out.println(file);<br></code></pre></td></tr></table></figure><ol><li>File(String parent, String child)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建文件对象</span><br><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\xiaohu\\Desktop&quot;</span>,<span class="hljs-string">&quot;Java.txt&quot;</span>);<br><br>System.out.println(file);<br></code></pre></td></tr></table></figure><ol><li>File(File parent, String child)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建文件夹对象</span><br><br><span class="hljs-type">File</span> <span class="hljs-variable">files</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\xiaohu\\Desktop&quot;</span>);<br><br><span class="hljs-comment">// 创建文件夹内的文件对象</span><br><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(files,<span class="hljs-string">&quot;Java.txt&quot;</span>);<br><br>System.out.println(file);<br></code></pre></td></tr></table></figure><p><strong>第一个参数一定需要是文件夹对象,否则就会出现异常</strong></p><h2 id="常用API方法获取基本信息"><a href="#常用API方法获取基本信息" class="headerlink" title="常用API方法获取基本信息"></a>常用API方法获取基本信息</h2><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>public String getName()</td><td>获取文件名</td></tr><tr><td>public String getPath()</td><td>获取文件路径</td></tr><tr><td>public String getAbsolutePath()</td><td>获取文件绝对路径</td></tr><tr><td>public File getAbsoluteFile()</td><td>获取绝对路径表示的文件</td></tr><tr><td>public String getParent()</td><td>获取上层文件夹路径,如果没有返回null</td></tr><tr><td>public long length()</td><td>获取文件长度(字节数),不能获取目录长度</td></tr><tr><td>public long lastModified()</td><td>获取文件最后一次修改的时间(毫秒)</td></tr></tbody></table></div><h2 id="获取文件夹内的所有文件-文件夹"><a href="#获取文件夹内的所有文件-文件夹" class="headerlink" title="获取文件夹内的所有文件/文件夹"></a>获取文件夹内的所有文件/文件夹</h2><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>public String[] list()</td><td>返回一个String数组,表示该文件夹中的所有文件/文件夹</td></tr><tr><td>public File[] listFile()</td><td>返回一个File数组,表示该文件夹中的所有文件/文件夹</td></tr></tbody></table></div><h2 id="文件-文件夹判断方法"><a href="#文件-文件夹判断方法" class="headerlink" title="文件/文件夹判断方法"></a>文件/文件夹判断方法</h2><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>public boolean exists()</td><td>此对象表示的文件/文件夹是否存在</td></tr><tr><td>public boolean isDirectory()</td><td>该File对象是否为文件夹</td></tr><tr><td>public boolean isFile()</td><td>该File对象是否为文件</td></tr><tr><td>public boolean canRead()</td><td>是否可读</td></tr><tr><td>public boolean canWrite()</td><td>是否可写</td></tr><tr><td>public boolean isHidden()</td><td>是否隐藏</td></tr></tbody></table></div><h2 id="创建-amp-amp-删除"><a href="#创建-amp-amp-删除" class="headerlink" title="创建&amp;&amp;删除"></a>创建&amp;&amp;删除</h2><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>创建文件,创建成功返回true,创建失败返回false</td></tr><tr><td>public boolean mkdir()</td><td>创建文件夹</td></tr><tr><td>public boolean mkdirs()</td><td>创建多级文件夹(也可以创建单个文件夹)</td></tr><tr><td>public boolean delete()</td><td>删除文件/文件夹</td></tr></tbody></table></div><ol><li>删除不走回收站</li><li>要删除文件夹必须是<code>空文件夹</code>,否则删除失败</li></ol><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常?"></a>什么是异常?</h2><p>异常就代表程序出现问题。学习异常不是为了程序不出异常,而是如何处理异常。</p><pre><code class=" mermaid">erDiagram&quot;Java.lang.Throwable&quot; ||--|&#123; Error : &quot;&quot;&quot;Java.lang.Throwable&quot; ||--|&#123; Exception : &quot;&quot;Exception ||--|&#123; RuntimeException : &quot;&quot;Exception ||--|&#123; &quot;其他异常&quot; : &quot;&quot;</code></pre><ol><li>Error: 代表系统级别的错误(属于严重问题), 开发人员不用管</li><li>Exception: 异常, 代表程序可能出现错误, 通常使用Exception以及它的子类封装程序出现的异常</li><li>RuntimeExcepton: 运行时异常, 运行时出现的异常</li><li>其他异常: 编译时异常, 编译时出现的异常, 除了RuntimeException和它的子类,其他的都是编译时异常</li></ol><h2 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h2><ol><li>JVM虚拟机默认的处理方式</li></ol><p>把异常名称,异常原因以及异常抛出的位置打印在控制台,并且停止程序运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        System.out.println(<span class="hljs-number">2</span>/<span class="hljs-number">0</span>);<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="hljs-comment">//at App.main(App.java:4)</span><br></code></pre></td></tr></table></figure><ol><li>自己处理(捕获异常)</li></ol><p>自己处理的方式可以当程序出现异常时, 捕获异常并且让程序继续运行, 不会停止程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br>        <br>        <span class="hljs-comment">// 捕获异常</span><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">// 出现异常的代码</span><br><br>            System.out.println(arr[<span class="hljs-number">10</span>]);<br><br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br><br>            <span class="hljs-comment">// catch内需要传递出现的异常参数, 出现的是哪一类异常写哪一类即可</span><br><br>            <span class="hljs-comment">// 如果出现 ArrayIndexOutOfBoundsException 异常, 该如何处理</span><br><br>            System.out.println(<span class="hljs-string">&quot;出现 索引越界 异常&quot;</span>);<br><br>            <span class="hljs-comment">// e为异常信息：java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 6</span><br><br>            System.out.println(e);<br><br>        &#125;<br><br>        <span class="hljs-comment">// 异常处理完毕之后,程序会继续往后执行</span><br>        System.out.println(<span class="hljs-string">&quot;程序运行中...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>如果try中没有出现问题,会运行try中的代码,catch中的代码不会出现</li><li>如果出现多个异常,可以使用<code>try..catch..catch..</code>捕获多个异常(如果多个异常中,出现父子关系,父类需要写在下面)</li></ol><h2 id="异常中的常见方法"><a href="#异常中的常见方法" class="headerlink" title="异常中的常见方法"></a>异常中的常见方法</h2><div class="table-container"><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>getMessage()</td><td>返回异常详细信息字符串</td></tr><tr><td>toString()</td><td>返回可抛出的简短描述</td></tr><tr><td>printStackTrace()</td><td>把异常错误信息输出在控制台</td></tr></tbody></table></div><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><ol><li>throws: 写在方法定义处,告诉调用者,使用本方法可能出现哪些异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 方法() <span class="hljs-keyword">throws</span> 异常类名<span class="hljs-number">1</span>,异常类名<span class="hljs-number">2.</span>...&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>thorw: 写在方法内,结束方法,手动抛出异常对象,交给调用者,方法中以下的代码将不会执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 方法&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ol><li>定义异常类</li><li>编写继承关系</li><li>空参构造以及带参构造</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 运行时异常继承RuntimeException, 编译时异常直接继承Exception即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CusException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>    <span class="hljs-comment">// 自定义异常类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CusException</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CusException</span><span class="hljs-params">(String message)</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于输出语句"><a href="#关于输出语句" class="headerlink" title="关于输出语句"></a>关于输出语句</h2><ol><li>正常的输出语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(<span class="hljs-string">&quot;Java&quot;</span>)<br></code></pre></td></tr></table></figure><ol><li>错误的输出语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.err.print(<span class="hljs-string">&quot;Java&quot;</span>)<br></code></pre></td></tr></table></figure><p>错误的输出语句会将输出的信息以红色的字体打印,会比正常的输出语句先打印</p><h2 id="什么是方法引用"><a href="#什么是方法引用" class="headerlink" title="什么是方法引用?"></a>什么是方法引用?</h2><p>把已经有的方法,拿来使用,当做函数式接口中抽象方法的方法体。</p><p>方法引用的条件:</p><ol><li>引用处必须是<code>函数式接口</code></li><li>被引用的方法必须已经存在</li><li>被引用的方法,形参与返回值必须与抽象方法保持一致</li><li>被引用的方法功能要能满足当前需求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建一个数组,进行倒序排列</span><br>        Integer[] arr = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;;<br>        <span class="hljs-comment">// 匿名内部类写法</span><br>        Arrays.sort(arr,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>             <span class="hljs-meta">@Override</span><br>             <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                 <span class="hljs-comment">// o1-o2为正序,o2-o1为倒序</span><br>                 <span class="hljs-keyword">return</span> o2 - o1;<br>             &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 输出[8, 7, 5, 4, 3, 1]</span><br>        <span class="hljs-comment">// Lambda表达式简写</span><br>        Arrays.sort(arr,(o1 , o2) -&gt; o2 - o1);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 输出[8, 7, 5, 4, 3, 1]</span><br>        <span class="hljs-comment">// 方法引用</span><br>        <span class="hljs-comment">// 表示把App类里面的subtraction方法当做抽象方法的方法体</span><br>        Arrays.sort(arr,App::subtraction);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 输出[8, 7, 5, 4, 3, 1]</span><br>    &#125;<br>    <span class="hljs-comment">// 被引用的方法 - 可以是Java已经写好的,也可以是Java的第三方类</span><br>    <span class="hljs-comment">// 形参与返回值需要与抽象方法的形参与返回值类型一致</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subtraction</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>        <span class="hljs-keyword">return</span> num2 - num1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h3><p>格式是 - 类名::静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>);<br><span class="hljs-comment">// 将字符串转化为数字类型</span><br><span class="hljs-comment">// 引用Integer内的parseInt方法,</span><br><span class="hljs-comment">// parseInt是内部静态方法,参数与返回值类型都与抽象方法相同,功能也一样,在此处就可以引用</span><br>list.stream().map(Integer::parseInt).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-comment">// 输出1 2 3 4 5</span><br></code></pre></td></tr></table></figure><h3 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h3><p>格式是 - 对象::成员方法</p><ol><li>其他类的: 其他类对象::方法名</li><li>本类的: this::方法名(引用处不能是静态方法,静态方法内没有this关键字)</li><li>父类的e: super::方法名</li><li>引用构造方法: 类名::new</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(list, <span class="hljs-string">&quot;Java&quot;</span>,<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;Javascript&quot;</span>,<span class="hljs-string">&quot;Html&quot;</span>,<span class="hljs-string">&quot;CSS&quot;</span>);<br>        <span class="hljs-comment">// 将字符串转化为数字类型</span><br>        <span class="hljs-comment">// 引用其他类成员方法</span><br>        list.stream().filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringOperation</span>()::StringJudeg).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot; &quot;</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringOperation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">StringJudeg</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-keyword">return</span> s.startsWith(<span class="hljs-string">&quot;J&quot;</span>) &amp;&amp; s.length() == <span class="hljs-number">4</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.stream.Collector;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(list, <span class="hljs-string">&quot;刘备,49&quot;</span>,<span class="hljs-string">&quot;刘邦,57&quot;</span>,<span class="hljs-string">&quot;刘禅,25&quot;</span>);<br>        <span class="hljs-comment">// 封装成Student对象，并收集到List集合, 引用构造方法</span><br>        List&lt;Student&gt; list2 = list.stream().map(Student::<span class="hljs-keyword">new</span>).collect(Collectors.toList());<br>        System.out.println(list2);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">// 引用构造方法时,返回值不需要管,</span><br>    <span class="hljs-comment">// 只需要保证,构造方法结束后生成的返回值与抽象方法返回值一致就可以</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String str)</span> &#123;<br>        String[] arr = str.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">this</span>.age = Integer.parseInt(arr[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类名引用成员方法"><a href="#类名引用成员方法" class="headerlink" title="类名引用成员方法"></a>类名引用成员方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;Java&quot;</span>,<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;Html&quot;</span>,<span class="hljs-string">&quot;CSS&quot;</span>,<span class="hljs-string">&quot;Vue&quot;</span>);<br><span class="hljs-comment">// 将字母全部转化为大写, 类名引用成员方法 ？？？</span><br><span class="hljs-comment">// 使用流内的每一个数据去调用String内的toUpperCase, 方法的返回值就是转换之后的结果</span><br>list.stream().map(String::toUpperCase).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-comment">// JAVA PYTHON HTML CSS VUE</span><br></code></pre></td></tr></table></figure><p>类引用成员方法独有规则:</p><ol><li>是函数式接口</li><li>被引用的方法必须已经存在</li><li>被引用方法的形参,需要与抽象方法第二个新参到最后一个形参,返回值保持一致</li><li>功能需要满足需求</li></ol><blockquote><p>抽象方法参数详解:第一个参数表示引用方法的调用者,决定了可以引用哪些类中的数据,在Stream流中,第一个参数表示流中的每一个数据。假设流内的数据为字符串,使用这种方式只能引用String类内的方法。第二个参数到最后的参数,跟引用方法的形参保持一致,如果没有,说明被引用的方法需要是无参的方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础】集合</title>
      <link href="/2025/03/28/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E9%9B%86%E5%90%88/"/>
      <url>/2025/03/28/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合:<code>存储对象的容器</code>,<code>存储对象</code>的<code>对象</code>。在数组中也可以存储对象,而用<code>Collection集合</code>存储对象,可以使对象有更多的特点和功能。特点是:容器的工具类,定义了对多个对象进行操作的方法。</p><p><code>Collection接口</code>的子类集合有些是允许有重复元素,有些没有。JDK不提供任何实现类直接实现此接口。Collection接口有很多抽象方法,是它子接口或者实现类共性的标准。</p><ol><li>特点:<br> 代表一组<code>任意类型</code>的对象,无序,无下标。</li><li>方法:<ol><li>.add(Object obj):添加一个对象return true or false</li><li>.addAll(Collection c):将一个集合中的所有元素添加进另外一个集合return true or false</li><li>.clear():清空集合 void</li><li>.contains(Object obj):判断集合中是否包含obj对象return true or false</li><li>.equals(Object obj):比较集合是否与指定对象相等return true or false</li><li>.isEmpty():判断此集合是否为空return true or false</li><li>.remove(Object obj):移除obj对象return true or false</li><li>.size():返回集合中的元素个数return int</li><li>.toArray():将集合转换为数组return Object[]</li></ol></li></ol><h3 id="List接口集合"><a href="#List接口集合" class="headerlink" title="List接口集合"></a>List接口集合</h3><p>List接口的特点:<code>有序</code>,<code>有下标</code>,<code>元素可重复</code>。</p><ol><li><code>.add(int index,Object obj)</code>-在index的位置上插上元素,<code>无返回值</code></li><li><code>.addAll(int index,Collection c)</code>-将一个集合中的元素添加到此集合中的index位置,返回boolean</li><li><code>.get(int index)</code>-获取指定位置的元素,返回Object</li><li><code>.subList(int fromIndex,int toIndex)</code>-返回它们之间的集合元素,返回List</li></ol><h4 id="ArrayList实现类"><a href="#ArrayList实现类" class="headerlink" title="ArrayList实现类"></a>ArrayList实现类</h4><p>ArrayList实现类遵循Collection和List接口的标准,所以ArrayList实现类具备<code>有序</code>,<code>有下标</code>,<code>元素可重复</code>三种特点。<code>底层是数据结构实现,查询快,增删慢</code>。</p><p><strong>注:当在中间插入元素时,后面的每个元素需要往后按顺序移动。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;E&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p><strong>注意其中<code>&lt;E&gt;</code>代表<code>泛型</code>。Java中,泛型通过&lt;&gt;来指定类型参数,如:ArrayList<String></strong></p><p>List接口的可调整数组大小实现。实现所有可选列表操作,并允许所有元素,包括null。除了实现List接口外,此类还提供一些方法来操作内部用于存储列表数据的大小。(这个类类似于Vertor,除了它是不同步的,所以在<code>线程不安全,但是运行效率快</code>)。</p><p><strong>ArrayList的构造方法:</strong></p><ol><li>ArrayList():构造一个初始容量为10的空列表。</li><li>ArrayList(int initialCapacity):构造一个具有指定初始容量的空列表。</li><li>ArrayList(Collection&lt;? extends E&gt; c):构造一个包含指定集合元素的列表,按照集合迭代器返回元素顺序。</li></ol><p><strong>注意:ArrayList实现类底层是一个数组;数组结构实现,查询快,增删慢。JDK6初始容量为10,JDK7初始容量改为0。？一开始初始化容量为10的话,不使用那么容器就会造成资源浪费,初始化改为0,只需添加一个元素会自动+1。</strong></p><blockquote><p>集合中只能包含引用数据类型,无法包含基础数据类型,想要集合中写入基础数据类型,需要通过<code>包装类</code>(用于将基本数据类型封装成数据类)。除了以下两个,剩下的只需将首字母大写就好了</p></blockquote><ol><li>Integet — 用于包装整形(int)</li><li>Character — 用于包装字符类型(char)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;<span class="hljs-type">int</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 报错,因为集合无法包含基础数据类型,需要采取包装类</span><br><br>ArrayList&lt;Integer&gt; List <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="Vector实现类"><a href="#Vector实现类" class="headerlink" title="Vector实现类"></a>Vector实现类</h4><p>Vector实现类与ArrayList实现类一样,都是<code>有序,有下标,元素可重复</code>,底层都是<code>数组结构实现,查询快,增删慢</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><blockquote><p>Vector与ArrayList类的区别在于:Vector的线程是安全的,但运行速率慢,而ArrayList类是不安全的,但运行速率快。如果不考虑线程安全问题,可以使用ArrayList代替Vector。</p></blockquote><h4 id="LinkedList实现类"><a href="#LinkedList实现类" class="headerlink" title="LinkedList实现类"></a>LinkedList实现类</h4><p>LinkedList实现类同样具备<code>有序,有下标,元素可重复</code>的特点。底层是<code>链表结构实现,查询慢,增删快。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>所有操作的执行都符合双向链表的预期。索引都列表中的操作将从开头或结尾遍历列表,以更接近指定索引的为准。</p><p><strong>在中间插入元素时,无需移动元素,直接开辟空间让前面的元素指向该空间</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础】字符串</title>
      <link href="/2025/03/27/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2025/03/27/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><p>单个字符需要使用<code>char</code>类型保存,多个字符组成的文本需要保存在<code>String</code>对象中。String通常被称为字符串,一个String对象最多可以保存<code>(2^32-1)</code>个字节的内容。</p><h3 id="声明字符串"><a href="#声明字符串" class="headerlink" title="声明字符串"></a>声明字符串</h3><p>在Java中,字符串必须被包含在一对<code>&quot;&quot;</code>之内。字符串可以是系统能够显示的任何信息,甚至可以是单个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br></code></pre></td></tr></table></figure><p>声明的字符串必须被<code>初始化</code>才能使用,不然编译器会报错。</p><h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><ol><li><p>直接创建:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>通过new来创建:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 甚至可以传入一个字符数组</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>])<br></code></pre></td></tr></table></figure></li></ol><h3 id="连接多个字符串"><a href="#连接多个字符串" class="headerlink" title="连接多个字符串"></a>连接多个字符串</h3><p>连接多个字符串,只需要使用<code>+</code>连接即可。连接其他数据类型,也是通过<code>+</code>连接即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot;World&quot;</span>);<br></code></pre></td></tr></table></figure></p><h3 id="获取字符串信息"><a href="#获取字符串信息" class="headerlink" title="获取字符串信息"></a>获取字符串信息</h3><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>通过String类中的<code>length()</code>方法可以获取声明的字符串长度(包括字符串中的空格)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>str.length(); <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><p>String类提供两种查找字符串的方法:<code>indexOf()</code>和<code>lastIndexOf()</code>,这两种方法都允许在字符串中<code>查找指定条件的字符或者字符串</code>。indexOf()方法返回的是搜索的字符或者字符串<code>首次出现的索引位置</code>,lastIndexOf()方法返回的是搜索的字符或者字符串<code>最后一次出现的索引位置</code>。</p><ol><li>indexOf(String str) 与 lastIndexOf(String str)</li></ol><p>如果没有查找到指定的字符或者字符串,<code>返回的值为-1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br><br>        System.out.println(str.indexOf(<span class="hljs-string">&#x27;l&#x27;</span>)); <span class="hljs-comment">// 输出2,即第一次&#x27;l&#x27;出现的索引位置</span><br>        System.out.println(str.lastIndexOf(<span class="hljs-string">&#x27;l&#x27;</span>)); <span class="hljs-comment">// 输出9,即最后一次&#x27;l&#x27;出现的索引位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取指定索引位置的字符"><a href="#获取指定索引位置的字符" class="headerlink" title="获取指定索引位置的字符"></a>获取指定索引位置的字符</h4><p>使用<code>charAt()</code>方法可以将指定索引处的方法返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.charAt(<span class="hljs-type">int</span> index);<br></code></pre></td></tr></table></figure><h3 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h3><h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h4><p>通过String类的<code>substring()</code>方法可以对字符串进行截取。</p><p><strong>substring(int beginIndex,int endIndex)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.substring(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">// 该方法返回从指定索引位置开始,到指定索引位置结束的字符串。endIndex不传就是截取到字符串末尾</span><br></code></pre></td></tr></table></figure><h4 id="去除字符串中的空格"><a href="#去除字符串中的空格" class="headerlink" title="去除字符串中的空格"></a>去除字符串中的空格</h4><p><code>trim()</code>方法,可以去除字符串中的前后空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   Hello World   &quot;</span>;<br>str.trim(); <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><h4 id="字符或字符串的替换"><a href="#字符或字符串的替换" class="headerlink" title="字符或字符串的替换"></a>字符或字符串的替换</h4><p><code>replace()</code>方法可以实现将字符串中指定的<code>字符或者字符串</code>全部<code>替换</code>为新的字符或字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.replace(<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>); <span class="hljs-comment">// HeLLo WorLd</span><br></code></pre></td></tr></table></figure><p><strong>第一个参数为指定的字符或字符串,第二个参数为要替换为的目标字符串</strong></p><h4 id="判断字符串的开始与结尾"><a href="#判断字符串的开始与结尾" class="headerlink" title="判断字符串的开始与结尾"></a>判断字符串的开始与结尾</h4><p><code>startsWith()</code>与<code>endsWith()</code>方法分别用于表示判断字符串是否已指定的字符或者字符串开始,返回值为boolean类型。</p><h5 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith()"></a>startsWith()</h5><p>判断字符串是否以指定字符或字符串开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.startsWith(<span class="hljs-string">&quot;H&quot;</span>)<br></code></pre></td></tr></table></figure><h5 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h5><p>判断字符串是否以指定字符或字符串结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.endsWith(<span class="hljs-string">&quot;d&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="判断字符串是否相等"><a href="#判断字符串是否相等" class="headerlink" title="判断字符串是否相等"></a>判断字符串是否相等</h4><p>对字符串对象进行比较不能只使用简单的<code>==</code>运算符,因为比较运算符比较的是两个字符串的地址是否相同,有时候<code>即便两个字符串的内容相同字符串的地址也是不同的</code>。</p><h5 id="equals-与-equalsIgnoreCase"><a href="#equals-与-equalsIgnoreCase" class="headerlink" title="equals() 与 equalsIgnoreCase()"></a>equals() 与 equalsIgnoreCase()</h5><p>如果只是判断两个字符串的内容是否相同,可以使用<code>equals()</code>方法与<code>equalsIgnoreCase()</code>方法。equals()方法比较两个字符串的内容是否相等,而equalsIgnoreCase()也可以比较内容,并且<code>是忽视大小写的</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;Hello World&quot;</span>.equals(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-string">&quot;Hello World&quot;</span>.equalsIgnoreCase(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="按字典顺序比较两个字符串"><a href="#按字典顺序比较两个字符串" class="headerlink" title="按字典顺序比较两个字符串"></a>按字典顺序比较两个字符串</h4><p><code>compareTo()</code>方法为<code>按字典顺序</code>比较两个字符串,该比较基于字符串中的各个字符的<code>Unicode</code>值,按字典顺序将对象表示的字符序列与参数字符串所表示的字符序列进行比较。如果String对象位于参数字符串之前,则结果为一个负数;如果String对象位于参数字符串之后,则结果为一个正数;如果相等,返回0,只有在equals()返回true的时候才会返回0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.compareTo(<span class="hljs-string">&quot;Hello&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="字母大小写转换"><a href="#字母大小写转换" class="headerlink" title="字母大小写转换"></a>字母大小写转换</h4><p>String类的<code>toLowerCase()方法</code>与<code>toUpperCase()方法</code>可以将字符串中的所有大写字母改为小写字母或者将所有的小写字母改为大写字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">str.toLowerCase(<span class="hljs-string">&quot;Hello World&quot;</span>); <span class="hljs-comment">// hello world</span><br>str.toUpperCase(<span class="hljs-string">&quot;Hello World&quot;</span>); <span class="hljs-comment">// HELLO WORLD</span><br></code></pre></td></tr></table></figure><h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><p>使用<code>split()</code>方法可以使字符串按指定的分割字符或字符串进行分割,并将分割后的结果存放在字符串数组中返回,<code>split()</code>方法提供两种分割形式。</p><h5 id="str-split-String-str1"><a href="#str-split-String-str1" class="headerlink" title="str.split(String str1)"></a>str.split(String str1)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;Hello World&quot;</span>.split(<span class="hljs-string">&quot;l&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果想定义多个分割符,可以使用符号”|”,例如”,|=”</p><h5 id="str-split-String-str1-int-limit"><a href="#str-split-String-str1-int-limit" class="headerlink" title="str.split(String str1,int limit)"></a>str.split(String str1,int limit)</h5><p>根据分割字符进行分割,并且限制分割次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.split(<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>String类的format()方法用于创建<code>格式化字符串</code>,format()方法有两种重载形式。</p><h5 id="format-String-format-Object…-args"><a href="#format-String-format-Object…-args" class="headerlink" title="format(String format,Object… args)"></a>format(String format,Object… args)</h5><p>方法使用指定的格式化字符串和参数返回一个格式化字符串,格式化后的新字符串使用本地默认的语言环境</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.format(String format,Object... args)<br></code></pre></td></tr></table></figure><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><div class="table-container"><table><thead><tr><th>转化符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%te</td><td>一个月中的某一天(1~31)</td><td>2</td></tr><tr><td>%tb/%tB</td><td>月份简称/全称</td><td>Feb/February</td></tr><tr><td>%ta/%tA</td><td>星期简称/全称</td><td>Sun/Sunday</td></tr><tr><td>%tc</td><td>包括全部日期与时间信息</td><td>星期六 3月 29 13:44:00 CST 2025</td></tr><tr><td>%tY/ty</td><td>四位/两位年份</td><td>2025/25</td></tr><tr><td>%tj</td><td>一年中的第几天(001-366)</td><td>085</td></tr><tr><td>%tm</td><td>月份</td><td>03</td></tr><tr><td>%td</td><td>一个月中的某一天(01~31)</td><td>02</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>        System.out.println(<span class="hljs-string">&quot;今年是:&quot;</span> + String.format(<span class="hljs-string">&quot;%tY&quot;</span>, date) + <span class="hljs-string">&quot;年&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;本月是:&quot;</span> + String.format(<span class="hljs-string">&quot;%tm&quot;</span>, date) + <span class="hljs-string">&quot;月&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;今日是:&quot;</span> + String.format(<span class="hljs-string">&quot;%td&quot;</span>, date) + <span class="hljs-string">&quot;号&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><div class="table-container"><table><thead><tr><th>转化符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%tH</td><td>小时(0~23)</td><td>13</td></tr><tr><td>%tI</td><td>小时(1~12)</td><td>01</td></tr><tr><td>%tK</td><td>小时(1~12)</td><td>1</td></tr><tr><td>%tM</td><td>分钟</td><td>44</td></tr><tr><td>%tS</td><td>秒</td><td>00</td></tr><tr><td>%tL</td><td>毫秒</td><td>000</td></tr><tr><td>%tQ</td><td>纳秒</td><td>000000000</td></tr><tr><td>%tZ/tz</td><td>时区/时区缩写</td><td>+0800/CST</td></tr><tr><td>%tp</td><td>上午/下午</td><td>上午/pm</td></tr><tr><td>%ts</td><td>1970-01-01 00:00:00到现在的秒数</td><td>12064515</td></tr><tr><td>%tQ</td><td>1970-01-01 00:00:00到现在的毫秒数</td><td>12066889455</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>        System.out.print(<span class="hljs-string">&quot;现在是:&quot;</span> + String.format(<span class="hljs-string">&quot;%tH&quot;</span>, date) + <span class="hljs-string">&quot;时&quot;</span>);<br>        System.out.print(String.format(<span class="hljs-string">&quot;%tM&quot;</span>, date) + <span class="hljs-string">&quot;分&quot;</span>);<br>        System.out.print(<span class="hljs-string">&quot;&quot;</span> + String.format(<span class="hljs-string">&quot;%tS&quot;</span>, date) + <span class="hljs-string">&quot;秒&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="日期与时间常见组合"><a href="#日期与时间常见组合" class="headerlink" title="日期与时间常见组合"></a>日期与时间常见组合</h4><div class="table-container"><table><thead><tr><th>格式化字符串</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%tF</td><td>“年-月-日”(4位年份)</td><td>2025-03-02</td></tr><tr><td>%tD</td><td>“年/月/日”(两位年份)</td><td>25/03/02</td></tr><tr><td>%tc</td><td>全部日期和时间信息</td><td>星期二 三月 25 15:20:00 CTS 2025</td></tr><tr><td>%tr</td><td>“时:分:秒 PM”</td><td>03:22:06 下午</td></tr><tr><td>%tT</td><td>“时:分:秒”</td><td>03:22:06</td></tr><tr><td>%tR</td><td>“时:分”</td><td>03:22</td></tr></tbody></table></div><h4 id="字符串生成器-StringBuilder"><a href="#字符串生成器-StringBuilder" class="headerlink" title="字符串生成器 StringBuilder"></a>字符串生成器 StringBuilder</h4><p>创建成功的字符串对象,其长度都是<code>固定的</code>,内容不能被修改与编译。虽然可以使用<code>+</code>达到字符串的拼接效果,但这样会产生一个新的String实例,<code>效率低</code>。而<code>可变的字符串序列StringBuilder类</code>可以大大提高频繁增加字符串的效率。</p><p>如果在程序中<code>频繁的附加字符串</code>,建议使用StringBuilder类。新创建的StringBuilder对象容量16字符,可自行指定初始长度,如果附加的字符超出容量,StringBuilder会自行增加容量,如果要输出字符串可以使用<code>toString()</code>方法。利用StringBuilder可以动态的执行字符串的增删改查操作。</p><h5 id="append-方法"><a href="#append-方法" class="headerlink" title="append()方法"></a>append()方法</h5><p>用于<code>向字符串生成器中追加内容</code>。通过重载,可以实现接收任何类型的参数或另一个字符串生成器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><br>        str.append(<span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">// 拼接字符串</span><br><br>        System.out.println(str); <span class="hljs-comment">// HelloWorld</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="insert-index-str-方法"><a href="#insert-index-str-方法" class="headerlink" title="insert(index,str)方法"></a>insert(index,str)方法</h5><p>该方法用于向字符串指定位置<code>插入数据</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Ho&quot;</span>);<br><br>        str.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ell&quot;</span>); <span class="hljs-comment">// 在H后面插入数据</span><br><br>        System.out.println(str); <span class="hljs-comment">// Hello</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="delete-start-end-方法"><a href="#delete-start-end-方法" class="headerlink" title="delete(start,end)方法"></a>delete(start,end)方法</h5><p><code>移除字符串中的字符</code>,从指定索引开始到指定索引结束<code>(不包括end索引的字符)</code>的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hehujunxillo&quot;</span>);<br><br>        str.delete(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>); <span class="hljs-comment">// 移除字符串</span><br><br>        System.out.println(str); <span class="hljs-comment">// Hello</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础】封装&amp;继承&amp;多态</title>
      <link href="/2025/03/26/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
      <url>/2025/03/26/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>在所有面向对象编程中,基本都有三大特性:<code>封装</code>,<code>继承</code>,<code>多态</code>。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><code>封装</code>就是将<code>对象的状态(数据)和行为(方法)打包在一起</code>,隐藏对象内部实现细节,只提供<code>公开的接口(getter,setter方法)</code>来与<code>对象进行交互</code>。</p><h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>在Java内,需要通过类的访问权限来实现封装,<code>访问权限修饰符</code>可以控制类,变量,方法或其他引用对象的访问级别。Java中有四种访问权限修饰符。</p><ol><li><code>private</code>:私有访问级别,只有同一个包中,同一个类才可以访问。</li><li><code>default</code>:默认级别,同一个包中,不同类也可以访问。</li><li><code>protected</code>:保护访问级别,不在同一个包中,只要是子类也可以访问。</li><li><code>public</code>:公共访问级别,任何地方都可以访问。</li></ol><p>一般情况下,成员变量定义<code>private</code>,成员方法定义<code>public</code>。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><code>包</code>其实就是一个文件夹,为了更好管理。将类划分,将多个类收集成一组就是一个包。在Java中,包是一种用来<code>组织与管理类和接口</code>的机制。可以为开发者提供一种<code>逻辑分组</code>的方式,使得代码更加模块化,结构化和易于管理。</p><h4 id="导包"><a href="#导包" class="headerlink" title="导包:"></a>导包:</h4><p>在Java内有许多内置类,如:<code>Date,Scanner</code>,需要使用<code>java.util.Date;</code>去导包。其实<code>java.util</code>就是包名,<code>Date</code>代表包中的类。</p><h4 id="自定义包"><a href="#自定义包" class="headerlink" title="自定义包:"></a>自定义包:</h4><ol><li>包名与代码路径的匹配。例如创建一个com.school.student的包,那么它对应的路径就是com/school/student。</li><li>包名尽量指定为唯一的名字(企业通常将自己企业的域名颠倒过来命名包名)。</li><li>当创建一个Java文件时,最上面的package语句就是指定该文件放在了那个包中。</li><li>如果一个类没有package语句,那么该类被放到默认包中。</li></ol><p>创建自定义包:右键<code>src</code>目录,选择<code>New Java Package</code>选项,输入包名即可</p><p><img src="https://pic1.imgdb.cn/item/67e379eb0ba3d5a1d7e37115.png" alt=""></p><p>创建好后就能看见创建的包目录了。在包目录内创建一个java文件,文件的顶部就会显示,该文件属于哪个包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件属于哪个包</span><br><span class="hljs-keyword">package</span> com.school.gzuhoaix;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="static-修饰的成员变量"><a href="#static-修饰的成员变量" class="headerlink" title="static 修饰的成员变量"></a>static 修饰的成员变量</h4><p>static修饰的成员变量,称为<code>静态成员变量</code>。静态成员变量不属于某个具体的对象,而是<code>所有的对象共享的</code>。</p><ol><li><p>特征:</p><ol><li>又称<code>静态属性</code>,不属于某个具体的对象,是类的属性,所有对象共享。</li><li>静态成员变量可以<code>通过类名直接访问</code>,也可以通过对象访问(为了区分静态成员变量,一般不会使用对象访问,更推荐使用<code>类名访问</code>)</li><li>静态成员变量<code>存储在堆的静态区</code>中。</li><li>生命周期随着类的加载而被创建,随着类的卸载而被销毁。与对象无关。</li></ol></li><li><p>示例:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">static</span> String occupation;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 通过类访问静态成员变量</span><br>        System.out.println(Person.occupation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>静态成员变量的初始化:</p><p> <code>静态成员变量一般不会在构造方法中初始化</code>。静态成员变量的初始化分为两种:<code>就地初始化</code>和<code>静态代码块初始化</code>。</p><ol><li>就地初始化:直接在定义静态成员变量时初始化赋值。</li><li><code>静态代码块初始化</code>:理解了代码块就知道了。</li></ol></li></ol><h4 id="static-修饰成员方法"><a href="#static-修饰成员方法" class="headerlink" title="static 修饰成员方法"></a>static 修饰成员方法</h4><p>在封装中,类的成员变量一般都设置为<code>private</code>,而成员方法设置为<code>public</code>,当成员变量被设置为private后,在其他类中,就不能直接访问,而是需要借助成员方法来进行访问。<br>与静态成员变量一样,在Java中static修饰的方法被称为静态成员方法,是类的方法,而不是某个特有对象的方法。<code>静态成员变量一般通过静态成员方法来访问</code>。<code>通过类名调用</code>,不推荐使用对象调用。</p><ol><li><p>注意:</p><ol><li>静态方法不需要对象调用,所以<code>不能传递this</code>。</li><li><code>静态方法</code>中不能调用任何<code>非静态成员变量</code>。</li><li>静态方法中不能调用任何<code>非静态方法</code>,但是可以在任何非静态方法中调用静态方法。</li></ol></li><li><p>示例:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">occupation</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;网站开发&quot;</span>;<br><br>    <span class="hljs-comment">// 静态成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getOccupation</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> occupation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 通过类访问静态成员方法获取静态成员变量</span><br>        System.out.println(Person.getOccupation());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h4><p>普通代码块就是定义在方法中的,拿<code>&#123;&#125;</code>包裹着的一段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;World!!!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例化代码块"><a href="#实例化代码块" class="headerlink" title="实例化代码块"></a>实例化代码块</h4><p>又叫构造代码块,一般用于<code>初始化实例成员变量</code>的时候。<code>实例化代码块的执行顺序优先于构造函数</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">occupation</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;网站开发&quot;</span>;<br>    String name;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;实例化代码块&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p><code>静态代码块</code>就是static定义的代码块,一般用于<code>初始化静态成员变量</code>。静态代码块的执行顺序优先于构造代码块。(静态代码块 -&gt; 构造代码块 -&gt; 构造函数)。静态代码块只会执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String occupation;<br>    String name;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>        <span class="hljs-comment">// 初始化静态成员变量</span><br>        occupation = <span class="hljs-string">&quot;网站开发&quot;</span>;<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;实例化代码块&quot;</span>);<br>        <span class="hljs-comment">// 初始化成员变量</span><br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ol><li>静态代码块只会执行一次。</li><li>如果一个类中定义了多个静态代码块,编译时,编译器会按照定义的先后顺序执行。</li><li>静态成员变量是类的属性,所以是在JVM加载类时开辟空间初始化的。</li><li>实例代码块只有在创建对象时才会执行,构造方法也是。</li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>程序世界中使用类对现实世界的实体来进行描述,而使用类实例化出来的对象就可以表示一个又一个的实体。但现实世界错综复杂,不同的实物之间又可能会存在一些联系。比如:手机,如今国内手机行业不像国外人均苹果,三星,国内有小米,华为,VIVO,OPPO,苹果…品牌。这些品牌它们都属于手机类,但它们又都有属于自己的特点,比如:苹果比较流畅,小米性价比高,vivo听说拍照比较不错之类的。这时候如果还与之前一样创建一个类存放这些手机,那这个类未免有些杂乱了。可如果定义三个类分别表示这些手机,那就会发现这三个类中有很多重复的代码。这时就可以使用<code>继承</code>,也就是将三个类中的<code>重复代码抽离出来</code>,放在一个父类,然后让这三个类继承自这个父类。</p><p>在Java中,如果要表示类之间的继承关系,需要借助<code>extends</code>关键字。继承的好处,就是可以<code>对代码进行复用</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>    <span class="hljs-comment">// 所有手机都有的成员变量</span><br>    <span class="hljs-type">int</span> price;<br>    String phoneName;<br>    String brand;<br><br>    <span class="hljs-comment">// 手机都有的成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 小米手机继承手机类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoMi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-comment">// 小米手机独有的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cheap</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;只要1999&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apple</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机很流畅&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vivo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">vivo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机拍照不错&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 实例化小米手机</span><br>        <span class="hljs-type">XiaoMi</span> <span class="hljs-variable">xiaomi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaoMi</span>();<br>        <span class="hljs-comment">// 声明手机类共有的成员变量</span><br>        xiaomi.price = <span class="hljs-number">1999</span>;<br>        xiaomi.phoneName = <span class="hljs-string">&quot;小米5s&quot;</span>;<br>        xiaomi.brand = <span class="hljs-string">&quot;小米手机&quot;</span>;<br><br>        <span class="hljs-comment">// 使用所有手机类共有的成员方法</span><br>        xiaomi.call();<br>        <span class="hljs-comment">// 使用小米手机类独有的成员方法</span><br>        xiaomi.cheap();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>注意:<ol><li>子类会将父类父类中的<code>成员变量</code>或者<code>成员方法</code>继承到子类中。</li><li>子类继承父类之后,必须要新添加自己特有的成员,体现出与父类的不同,否则就没有必要继承了。</li></ol></li></ol><h3 id="父类成员变量与成员方法的访问"><a href="#父类成员变量与成员方法的访问" class="headerlink" title="父类成员变量与成员方法的访问"></a>父类成员变量与成员方法的访问</h3><ol><li>子类中存在而父类中不存在的成员变量,直接访问即可。</li><li><p>子类中存在父类中也存在的同名成员变量,此时直接访问会优先访问子类中的成员变量。</p></li><li><p><code>子类方法中</code>或者<code>通过子类对象访问成员</code>时:</p><ol><li>如果访问的成员变量子类中有时,优先访问子类的成员变量。</li><li>如果访问的成员变量子类中没有,则访问父类继承的,如果依然没有就会有语法错误。</li><li>访问的成员变量与父类的成员变量同名,<code>优先访问自己的</code>。</li></ol></li><li><p>访问成员方法时:</p><ol><li>通过子类对象访问父类与子类中不同名的方法时,依然是优先访问子类,其次才是父类。</li><li>通过派生类对象访问父类与子类同名方法时,如果父类与子类同名方法参数列表不同(重载),根据传递的参数选择合适的访问即可。</li></ol></li></ol><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>有时子类与父类中,可能存在相同名称的成员,如果要在子类方法中访问父类中的<code>同名成员变量</code>,一般情况是访问不到的。Java提供了<code>super</code>关键字,该关键字的主要作用就是在子类中访问父类的成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSpedd</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 此时获取到的speed属性,就是Car类中的speed属性</span><br>        System.out.println(<span class="hljs-built_in">super</span>.speed); <span class="hljs-comment">// 2000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在子类中获取父类的同名成员变量只需要借助<code>super</code>即可。只能在<code>非静态方法与非静态代码块</code>中使用。</p><h3 id="子类构造方法"><a href="#子类构造方法" class="headerlink" title="子类构造方法"></a>子类构造方法</h3><p>子类对象构造时,需要<code>先执行父类的构造方法</code>,然后在执行子类的构造方法。原因是子类对象中的成员是由两部分组成的,父类继承的以及子类新增的。所以构造子类时,需要先调用父类的构造函数,将从<code>父类继承下来的成员</code>构造完整,然后再调用子类自己的构造方法,将自己<code>新增的成员完成初始化</code>。<br>子类构造方法中<code>super()</code>可以调用父类构造方法,而且<code>super()</code>语句必须放在<code>第一行</code>(有点类似于this())。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> speed;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> speed)</span>&#123;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    String color;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Train</span><span class="hljs-params">(<span class="hljs-type">int</span> speed,String color)</span>&#123;<br>        <span class="hljs-built_in">super</span>(speed);<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Train</span> <span class="hljs-variable">tr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;red&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>若父类显示定义无参数或者默认的构造函数,则在子类构造函数的第一行默认有隐藏的super()调用。</li><li>如果父类构造函数带参,此时需要用户为子类手动定义构造方法,并在子类构造方法中选择合适的父类构造方法调用。</li><li>在子类构造方法中super(…)调用父类构造时,必须是子类构造函数中的第一条语句。</li><li>super(…)只能在子类构造方法中出现一次,并且不能和<code>this</code>同时出现。</li></ol><h3 id="super与this的区别"><a href="#super与this的区别" class="headerlink" title="super与this的区别"></a>super与this的区别</h3><p>super与this都可以在成员方法中用来访问:成员变量和调用其他的成员函数,都可以作为构造函数的第一条语句。</p><ol><li><p>相同点:</p><ol><li>都是Java中的关键字。</li><li>只能在类的<code>非静态方法</code>中使用,用来访问<code>非静态成员方法与字段</code>。</li><li>在构造函数中调用时,必须作为构造函数的第一条语句,<code>不能同时出现</code>。</li></ol></li><li><p>不同点:</p><ol><li>this是当前对象的引用,即调用当前实例方法的对象。super相当于子类中继承自父类的部分成员的引用。</li><li>在非静态的成员方法中,this用来访问<code>本类的方法与属性</code>,super用来访问<code>父类继承下来的方法与属性</code>。</li><li>在构造方法中:this(…)<code>用于调用本类构造函数</code>。super(…)用于调用父类构造函数,两者调用不能同时出现。</li><li>构造方法中一定会存在super(…)的调用(有父类的方法),用户不写也会默认增加,但this(…)用户不写就不会增加。</li></ol></li></ol><h3 id="初始化语句执行顺序"><a href="#初始化语句执行顺序" class="headerlink" title="初始化语句执行顺序"></a>初始化语句执行顺序</h3><ol><li>最先执行应该是<code>父类的静态代码块</code>,紧接着是<code>子类的静态代码块</code>。</li><li>父类实例化代码块与父类构造函数开始执行。</li><li>子类实例化代码块与子类构造函数执行。</li><li>第二次实例化子类对象时,父类与子类的静态代码块都不会在执行。</li></ol><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><ol><li>单继承:也就是一个子类继承自一个父类。</li><li>多继承:一个子类继承自一个父类,而子类又被一个更小的类继承。</li><li>不同类继承同一个类:一个父类被多个子类同时继承。</li></ol><blockquote><p>注意:Java不支持一个子类同时继承自两个或两个以上的父类。在真正的项目开发中,往往业务会很复杂,类也会很多,类与类之间的关系也很复杂,一般不希望出现三层以上的继承关系,如果继承层太多,就需要考虑对面代码进行重构,想从语法上限制继承,可以使用”final”关键字。</p></blockquote><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><h4 id="final-修饰变量"><a href="#final-修饰变量" class="headerlink" title="final 修饰变量:"></a>final 修饰变量:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>final修饰的变量或字段,表示<code>常量</code>(即不能被修改)。final修饰的<code>常量最好使用全大写字母</code>。</p><h4 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类:"></a>final修饰类:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>final 修饰的类<code>表示不能被继承</code>。也叫<code>封装类</code>。</p><h4 id="final-修饰方法"><a href="#final-修饰方法" class="headerlink" title="final 修饰方法:"></a>final 修饰方法:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>final 修饰的方法表示该方法<code>不能被重写</code>。</p><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><p>与继承类似,组合也是一种表示类之间关系的方式,也能够达到代码重用的效果。组合并没有涉及到特殊的语法,<code>仅仅是将一个类的实例对象作为另一个类的成员变量</code>。<br>继承表示对象之间是…的关系,如:男人是人,女人是人。组合表示对象之间有…的关系,如:汽车有发动机,有轮胎。学校内有多个老师与同学,只有一位校长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span> &#123;<br>    <span class="hljs-comment">// 将别的类实例化对象作为此类成员变量</span><br>    <span class="hljs-keyword">public</span> Student[] students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 多个学生</span><br>    <span class="hljs-keyword">public</span> Teacher[] teachers; <span class="hljs-comment">// 多个老师</span><br>    <span class="hljs-keyword">public</span> President president; <span class="hljs-comment">// 一位校长</span><br>&#125;<br><br><span class="hljs-comment">// 学生</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 老师</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 校长</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">President</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是同一个行为具有<code>不同的表现形式</code>或形态的能力,同一个方法可以根据<code>发送对象</code>的不同采取不同的行为方式。总的来说多态就是事物的多种形态,一个对象在不同条件下所表现的不同形式。</p><ol><li><p>如何实现多态:</p><ol><li>在多态中必须存在<code>继承或实现关系</code>的子类和父类。</li><li>子类对父类的某些方法进行重新定义。</li><li>通过<code>父类的引用</code>调用重写的方法。</li></ol></li><li><p>格式:</p><ul><li>父类类名 变量名 = new 子类类名();</li><li>通过<code>变量名.方法名()</code>,这种格式来调用在<code>子类中重写</code>的方法。</li></ul></li></ol><h3 id="多态中的成员变量"><a href="#多态中的成员变量" class="headerlink" title="多态中的成员变量"></a>多态中的成员变量</h3><p><code>编译运行看左边,即看的是父类中的变量。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>();<br><br>        System.out.println(car.speed); <span class="hljs-comment">// 此时打印的是父类中的变量,也就是1000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>父类声明子类实例这种的<code>成员变量</code>,都是编译运行看左边,也就是获取到的是父类中的成员变脸。</p><h3 id="多态中的成员方法"><a href="#多态中的成员方法" class="headerlink" title="多态中的成员方法"></a>多态中的成员方法</h3><p><code>编译看左边,运行看右边</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Car is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Train is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>();<br><br>        System.out.println(car.speed); <span class="hljs-comment">// 此时打印的是父类中的变量,也就是1000</span><br>        car.run(); <span class="hljs-comment">// 此时输出&quot;Train is running&quot;,即调用的是子类中重写的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当子类的方法与父类的方法有<code>相同的名称</code>,<code>返回类型</code>,<code>参数列表</code>此时间就会发生<code>重写</code>现象,这是会<code>调用子类的成员方法</code>来取代父类的实现。这里只是针对子类与父类方法名相同的成员方法才会发生的情况。</p><h3 id="重写的注意事项"><a href="#重写的注意事项" class="headerlink" title="重写的注意事项"></a>重写的注意事项</h3><ol><li><code>方法名</code>必须相同</li><li><code>参数列表</code>必须相同(类型,个数,顺序)</li><li><code>返回值</code>必须相同,如果想要返回值类型不同,则返回关系类型必须为父子类关系。</li><li>父类<code>被private修饰</code>的方法,不能进行重写。</li><li>父类<code>被static修饰</code>的方法,不能进行重写。</li><li>父类<code>被final修饰</code>的方法,不能进行重写,此时这个方法被叫做<code>密封方法</code>。</li><li>构造方法不能重写。</li><li>访问修饰限定符private&lt;默认权限(即什么都不写)&lt; protected &lt; public子类的访问修饰限定符权限一定要大于等于父类,才能发生重写现象。</li></ol><p><strong>重写这个运行过程一般也被称为<code>动态绑定</code></strong></p><h3 id="多态特点"><a href="#多态特点" class="headerlink" title="多态特点"></a>多态特点</h3><ol><li>当子类与父类存在相同的成员变量时,编译器会访问<code>父类的成员变量</code></li><li>当子类与父类存在相同的成员方法时,此时会发生<code>重写</code>现象,编译器会访问子类中的成员方法</li><li>当子类中有方法,而父类没有时,则不能访问子类中独有的方法(也不是不行,需要一些手段)</li><li>子类与父类存在同名的<code>静态成员函数</code>时,访问的是<code>父类的成员函数</code></li><li>以上这些特点均是在<code>多态的情况下发生</code>的</li></ol><h2 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h2><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p><code>向上转型</code>是Java中常用的类型转换方式之一,也称为<code>自动类型转换</code>。这种类型转换发生在继承关系中,父子类之间,通常是将<code>子类对象转换为父类对象</code>。</p><p><strong>向上转型的三种方法：</strong></p><pre><code class="hljs">1. 直接赋值2. 方法传递的参数3. 返回值</code></pre><h4 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Train</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">super</span>(speed, color);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>); <span class="hljs-comment">// 直接赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Car is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Train</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">super</span>(speed, color);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Train is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>); <span class="hljs-comment">// 直接赋值</span><br>        fun(car); <span class="hljs-comment">// 以car作为参数传值</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(Car car)</span>&#123;<br>        car.run(); <span class="hljs-comment">// 输出&quot;Train is running&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> fun(); <span class="hljs-comment">// 返回值</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;red&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上就是向上转型的是那种方式,可以看出向上转型无法调用子类特有的方法,只能调用父类自己的方法,除非发生方法重写,否则无法调用。</p></blockquote><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>将一个子类对象向上转型可以当做父类对象使用,如果需要<code>调用子类特有的方法</code>,则只需将<code>父类对象在转换为子类对象</code>即可,这就是<code>向下转型</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>);<br><br>        <span class="hljs-type">Train</span> <span class="hljs-variable">train</span> <span class="hljs-operator">=</span> (Train)car; <span class="hljs-comment">// 向下转型,将父类对象强制转换为子类</span><br><br>        train.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>向下转型之后,不仅可以调用父类的方法,还可以<code>调用子类特有的方法</code>。</p><h4 id="向下转型缺点"><a href="#向下转型缺点" class="headerlink" title="向下转型缺点"></a>向下转型缺点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Car is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Train</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">super</span>(speed, color);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Train is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 新增一个子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Bus is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>);<br><br>        <span class="hljs-type">Bus</span> <span class="hljs-variable">bus</span> <span class="hljs-operator">=</span> (Bus)car; <span class="hljs-comment">// 向下转型,将父类对象强制转换为子类</span><br><br>        bus.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时代码虽然没有语法错误,但是运行之后就会报异常,即类型转换异常。</p><blockquote><p>Exception in thread “main” java.lang.ClassCastException: class Train cannot be cast to class Bus (Train and Bus are in unnamed module of loader ‘app’) at App.main(App.java:5)</p></blockquote><ol><li>在启动项中,向上转型的过程,car这个对象是由Train类所构造出来的</li><li>而在向下转型的过程中,把car这个对象转换为了Bus类对象</li><li>虽然Train和Bus都是Car的子类</li><li>但将Train对象转换为Bus对象还是不科学</li></ol><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>想要避免向下转型遇到的类型转换异常,可以使用<code>instanceof</code>关键字,instanceof关键字的作用就是检测其变量类型是否属于该数据类型或者他的子类类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>);<br><br>        <span class="hljs-comment">// 判断car是否是Train类型或者Train子类类型</span><br>        <span class="hljs-keyword">if</span>(car <span class="hljs-keyword">instanceof</span> Train)&#123;<br>            <span class="hljs-type">Train</span> <span class="hljs-variable">train</span> <span class="hljs-operator">=</span> (Train)car;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络之间的通信原理</title>
      <link href="/2025/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%BA%92%E8%81%94%E7%BD%91%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
      <url>/2025/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%BA%92%E8%81%94%E7%BD%91%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><p><code>互联网(Internet)</code>是现代社会中<code>信息传递</code>,交流与商业活动的基础设施。它不仅是全球计算机网络的集合体,还连接着全球范围内的各种信息系统和服务。</p><h3 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet?"></a>什么是Internet?</h3><p>互联网是一个全球性的<code>计算机网络</code>,利用一套统一的<code>计算机协议(TCP/IP)</code>,连接无数个<code>局域网(LAN)</code>,<code>广域网(WAN)</code>以及其他类型网络。通过互联网,全球范围内的用户可以共享资源,进行数据交换,访问各种信息与服务。互联网本身并不同于’网络’,它是一个庞大分布广泛的计算机网络系统。由各种<code>网络设备(路由器,交换机,服务器...)</code>和<code>通信协议(IP协议,TCP协议,UDP协议...)</code>组成,利用这些设备与协议,不同设备之间可以实现跨地域的互联网通信。</p><h3 id="互联网工作原理"><a href="#互联网工作原理" class="headerlink" title="互联网工作原理"></a>互联网工作原理</h3><p>互联网核心工作原理包括<code>数据传输</code>,<code>地址分配</code>,<code>通信协议</code>…</p><h4 id="分层模型OSI与TCP-IP"><a href="#分层模型OSI与TCP-IP" class="headerlink" title="分层模型OSI与TCP/IP"></a>分层模型<code>OSI</code>与<code>TCP/IP</code></h4><p><code>互联网通信</code>通过分层模型进行管理,最常见的分层模型是<code>TCP/IP模型</code>与<code>OSI模型</code>,其中TCP/IP模型是互联网中标准协议栈。它由四个层次组成:</p><ol><li>应用层:提供网络服务与用户交互页面,如:HTTP,FIP,SMTP…</li><li>传输层:确保数据的可靠传输,常用的协议有TCP,UDP…</li><li>网络层:负责数据包的寻址和路由,做重要的协议是IP(Internet Protocol)</li><li>数据链路层:确保数据能够在物理网络上可靠传输,涉及物理地址(MAC地址)</li></ol><h4 id="数据传输流程"><a href="#数据传输流程" class="headerlink" title="数据传输流程"></a>数据传输流程</h4><p>互联网数据传输通常依赖于<code>数据包交换</code>技术。用户发送数据时,数据会被分割为多个小数据包,这些数据包在网络中通过不同的路由器和交换机进行转发。最终,这些数据包会在目的地组装为完整的数据流。</p><ol><li>分割数据:数据被分割为较小的数据包,每个数据包有一个头部,包含目的地址与其他控制信息</li><li>路由选择:数据包通过路由器传输,每个路由器根据路由表来决定数据包的转发路径。</li><li>数据接收与重组:目的设备收到数据包后,按照数据包头部信息将其重组为完整数据。</li></ol><h4 id="IP地址与域名系统-DNS"><a href="#IP地址与域名系统-DNS" class="headerlink" title="IP地址与域名系统(DNS)"></a>IP地址与域名系统(DNS)</h4><ol><li><p><code>IP地址</code>:每个连接到互联网的设备都有一个唯一的IP地址(Internet Protocol Address),它用来标识设备在网络中的位置。常见的IP地址格式有IPv4(192.168.0.1)和IPv6(2001:0db8:85a3:0000:0000:8a2e:0370:7334)。</p></li><li><p><code>DNS(域名系统)</code>:DNS系统将人类可读的域名(www.baidu.com)转化为计算机能够识别的IP地址。DNS相当互联网中的电话溥,帮助用户通过易记得地址访问网站。</p></li></ol><h3 id="互联网基础技术与协议"><a href="#互联网基础技术与协议" class="headerlink" title="互联网基础技术与协议"></a>互联网基础技术与协议</h3><p>互联网的高效运行依赖于多种基础技术与协议,它们决定了数据的传输方式,网络的管理和访问控制等。</p><h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h4><p><code>TCP/IP协议族</code>是互联网通信的基础协议,分为多个层次,常用的协议包括:</p><ol><li><p>TCP(传输控制协议):确保数据的可靠传输。TCP通过三次握手建立连接,确保数据按顺序到达目标,并进行错误检测和修复。</p></li><li><p>IP(互联网协议):负责数据包的寻址与路由,确保数据包能从源设备传送带目的设备。</p></li><li><p>UDP(用户数据报协议):与TCP类似,但不提供可靠性保障,适用于<code>实时应用</code>,如:视频流,语音通信…</p></li></ol><h4 id="HTTP-HTTPS协议"><a href="#HTTP-HTTPS协议" class="headerlink" title="HTTP/HTTPS协议"></a>HTTP/HTTPS协议</h4><ol><li><p><code>HTTP(超文本传输协议)</code>:用于网页数据传输。HTTP协议无状态,即每次请求与响应都是独立的,不会记住之前的请求信息。</p></li><li><p><code>HTTPS(安全超文本传输协议)</code>:是HTTP加密版本,使用<code>SSL/TLS协议</code>加密通信,保证数据在传输过程中的安全性。</p></li></ol><h4 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h4><p><code>FTP(文件传输协议)</code>用于在互联网中传输文件。用户可以通过FTP客户端与FTP服务器进行文件的上传与下载。</p><h4 id="SMTP-POP3-IMAP协议"><a href="#SMTP-POP3-IMAP协议" class="headerlink" title="SMTP/POP3/IMAP协议"></a>SMTP/POP3/IMAP协议</h4><p>这些协议用于<code>电子邮件</code>的传输与接收。</p><ol><li><code>SMTP(简单邮件传输协议)</code>:用于发送邮件。</li><li><code>POP3(邮局协议3)</code>:用于从邮件服务器下载邮件。</li><li><code>IMAP(互联网邮件访问协议)</code>:与POP3类似,但提供更加灵活的邮件管理功能,允许用户在服务器上直接管理邮件。</li></ol><h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><p>DNS协议用于将域名解析为IP地址,使用户可以通过域名来访问网站,而不需要记复杂的IP地址。</p><h3 id="互联网的安全性与隐私保护"><a href="#互联网的安全性与隐私保护" class="headerlink" title="互联网的安全性与隐私保护"></a>互联网的安全性与隐私保护</h3><p>随着互联网的普及,网络安全问题越来越受到关注,用户的数据与隐私容易受到黑客攻击,网络钓鱼,恶意软件…常见的互联网安全措施包括:</p><ol><li><code>SSL/TLS加密</code>:保护用户的数据传输安全,防止中间人攻击。</li><li><code>防火墙和入侵检测系统</code>:监控和控制网络流量,防止不良攻击。</li><li><code>身份验证与授权</code>:确保只有授权用户才可以访问敏感资源。</li><li><code>VPN(虚拟私人网络)</code>:提供加密的远程访问,保护用户的上网隐私。</li></ol><h2 id="WEB通信流程"><a href="#WEB通信流程" class="headerlink" title="WEB通信流程"></a>WEB通信流程</h2><ol><li>浏览器本身是一个客户端,当输入URL时,首先浏览器回去请求<code>DNS服务器</code>,通过DNS获取相应的域名与IP。</li><li>通过<code>IP</code>找到IP对应的服务器,要求建立<code>TCP连接</code>。</li><li>等浏览器发送完<code>HTTP Request请求包</code>后,服务器收到请求包,开始处理请求包。</li><li>服务器调用自身服务器,返回<code>HTTP Response响应包</code>。</li><li>客户端收到来自服务器的响应包之后,开始渲染响应包内的主体<code>(响应体body)</code>,等收到全部的内容后断开与该服务器的TCP连接。</li></ol><p><img src="https://pic1.imgdb.cn/item/67e116ae0ba3d5a1d7e2905a.png" alt="WEB通信流程"></p><h3 id="WEB服务器工作原理"><a href="#WEB服务器工作原理" class="headerlink" title="WEB服务器工作原理"></a>WEB服务器工作原理</h3><ol><li>客户端通过TCP/IP协议建立到服务器的TCP连接。</li><li>客户端向服务器发送HTTP协议请求包,请求服务器里的资源文档。</li><li>服务器向客户端发送HTTP协议响应包,如果请求的资源包含有动态语言的内容,那么服务器会调用动态语言的解释引擎处理<code>动态内容</code>,并将处理的数据返回给客户端。</li><li>客户端与服务器断开,由客户端解释HTML文档,在客户端屏幕上渲染图形结果。</li></ol><p><img src="https://pic1.imgdb.cn/item/67e1187b0ba3d5a1d7e29113.png" alt="WEB服务器工作原理"></p><h3 id="客户端请求到服务器流程"><a href="#客户端请求到服务器流程" class="headerlink" title="客户端请求到服务器流程"></a>客户端请求到服务器流程</h3><ol><li><p>当客户端拿到服务器域名对应的IP后,浏览器会以一个<code>随机端口(1024&lt;端口&lt;65535)</code>向服务器的web程序(nginx,tomcat)的80端口发起TCP连接请求。</p></li><li><p>该请求经过复杂的网络环境到达服务器后,进入服务器的对应网卡,再进入到<code>Linux内核</code>的TCP/IP协议栈,一层一层解开数据包,甚至经过防火墙,最终到达nginx程序,确认TCP/IP连接。</p></li><li><p>确认TCP连接之后,客户端继续发起HTTP请求,如:get,post…请求方法。</p></li></ol><p><img src="https://pic1.imgdb.cn/item/67e118710ba3d5a1d7e2910d.png" alt="客户端请求到服务器流程"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础】面向对象与类</title>
      <link href="/2025/03/23/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2025/03/23/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Java是一门<code>纯面向对象语言</code>,在面向对象的世界里,一切皆为对象。面向对象是解决问题的一种思路,主要通过对象之间的交互完成一件事情。<br>面向对象的程序是由对象组成的,每个对象包含<code>对用户公开的特定功能</code>和<code>隐藏的实现部分</code>。Java中有很多对象来自<code>标准库</code>,还有一部分由自己定义。从根本上说只要对象能够满足要求,就不必关心其功能实现过程。在<code>OOP</code>中不必关心对象的具体实现,只需其能满足用户需求即可。<br>以面向对象的方式进行处理,就不需要关注工作执行的过程。通过对象之间的交互就可以完成一件事情。面向对象编程的本质是以<code>类的方式</code>组织代码,以对象组织(封装)数据。</p><hr><h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><p><code>面向对象</code>与<code>面向过程</code>都是对项目分析,设计,开发的一种思想,它指导人们以不同的方式分析,设计和开发软件。</p><blockquote><p><code>面向过程</code>:面向过程适合简单,不需要协作的事务,重点关注执行的过程。面向过程时,需要思考怎样<code>按步骤实现</code>并将步骤对应为方法,一步步完成项目。例如把大象装进冰箱内,首先需要打开冰箱,然后把大象放进去,最后关上冰箱。</p><p><code>面向对象</code>:当思考比较复杂的设计任务时,会发现面对过程的思想比较复杂,此时面向对象的思想就应运而生了。<code>面向对象(OOP)</code>更契合人的思维模式。比如使用面向对象的思维去造车,就会想车是由轮胎,发动机,座椅,玻璃…组成的,这样只需要将这些部件组装起来就行,整个过程由这些对象之间的交互完成,而不需要关注那些对象之中的过程。因此面向对象是从整体去分析整个系统。</p></blockquote><p>面向对象与面向过程并不是编程语言,而是解决问题的一种思维方式。其中面向过程是一种执行者思维,面向对象是一种设计者思维,<code>面向对象离不开面向过程</code>。面向过程适合解决简单问题,面向对象适合解决困难的需要协作的问题。</p><h3 id="面向对象编程快速入门"><a href="#面向对象编程快速入门" class="headerlink" title="面向对象编程快速入门"></a>面向对象编程快速入门</h3><ol><li>面向对象的三个特征:<code>封装</code>,<code>继承</code>,<code>多态</code>。</li><li>创建一个一个的对象,将数据交给对象,在调用对象的方法来完成对数据的处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 类内的属性</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-comment">// 类内的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,My name is&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Main函数中....</span><br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 导包</span><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 实用类创建对象,也叫实例化对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        <span class="hljs-comment">// 给对象添加属性值</span><br>        stu.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>        stu.age = <span class="hljs-number">18</span>;<br>        stu.sex = <span class="hljs-string">&quot;男&quot;</span>;<br><br>        <span class="hljs-comment">// 使用对象调用类内的方法</span><br>        stu.hello();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="深刻认识面向对象"><a href="#深刻认识面向对象" class="headerlink" title="深刻认识面向对象"></a>深刻认识面向对象</h3><ol><li>面向对象编程的好处:<ol><li>凡事找对象的编程套路,更加符合人类思维习惯,编程也更加直观。</li></ol></li><li>对象是什么?如何创建?<ol><li>对象的本质就是一种特殊的<code>数据结构</code>(如果你学过<code>js</code>,一定对对象类型很熟悉,<code>obj=&#123;name:&#39;小明&#39;,age:18&#125;</code>,其实与这个对象差不多,只是现在说的对象更底层一点)</li><li>对象是用类new出来的,有类就可以创建对应的对象。</li><li>class也是类,也被称为对象的设计图(或者对象的模板)</li></ol></li></ol><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ol><li>类:用于描述对象里面具有的属性与行为。</li><li>对象:被类实例化创建出来,在内存中实际存在的。</li></ol><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>在JAVA中定义类时,需要使用<code>class</code>关键字。class后面的是类名,可以按照自己的取,但是要符合大坨峰命名法的规范。不止java,很多语言皆是如此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-comment">// 定义成员属性/成员方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>定义一个类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-comment">// 成员属性</span><br>    String name;<br><br>    <span class="hljs-comment">// 成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;正在吃东西&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ol><li>类名采用大坨峰命名法。</li><li>类内的属性叫做<code>成员属性/成员变量</code>,类内的方法叫做<code>成员方法/成员行为</code>。</li><li>public是来控制<code>访问权限</code>的,是封装内的内容。</li><li>一般一个文件只定义一个类。</li><li>main方法所在的类一般要使用public修饰。</li><li>public修饰的类名必须与文件名相同(尽量都保证类名与文件名相同),如果要在一个文件写多个类,那么其他类可以不用加public。</li><li>成员变量本身存在默认值,在定义成员变量时一般来说不需要初始化值。</li><li>对象与对象之间不会相互影响,但<code>多个变量指向同一个变量时就会相互影响</code>(引用类型)。</li><li>如果某个对象没有一个变量引用,那么该对象无法被操作,该对象会成为所谓的垃圾对象。</li></ol></li></ol><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><blockquote><p>定义一个类,就相当于在计算机中自定义了一种新的数据类型。与int,double类似,只不过int,double是内置类型,而类是用户自定义的类型。用类创建对象的过程被称为<code>类的实例化</code>,在java中采用new关键字配合类名来实例化对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 类的实例化</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        <span class="hljs-comment">// 给对象添加属性值</span><br>        stu.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>        stu.age = <span class="hljs-number">18</span>;<br>        stu.sex = <span class="hljs-string">&quot;男&quot;</span>;<br><br>        <span class="hljs-comment">// 使用对象调用类内的成员方法</span><br>        stu.hello(); <span class="hljs-comment">// 输出&quot;hello,My name is 小明&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 成员属性</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-comment">// 成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,My name is&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>注意事项</code>:当使用类实例化了一个对象后,对象身上就具备类的所有成员属性与成员方法。可以给这些属性赋值,也可以<code>通过对象调用这些成员方法</code>。当调用这个成员方法时,如果<code>成员方法内使用了成员属性</code>,那么<code>属性值应该是调用方法的对象身上的属性值</code>,而不是其他的一些什么。</p><h3 id="对象在计算机中的执行原理"><a href="#对象在计算机中的执行原理" class="headerlink" title="对象在计算机中的执行原理"></a>对象在计算机中的执行原理</h3><ol><li><code>类加载</code>:当Java程序启动时,<code>Java虚拟机(JVM)</code>会加载<code>Student</code>类和<code>Main</code>类的字节码文件,并将类的元数据信息存储到方法区中,包括类的结构,字段,方法,常量池…</li><li><code>main方法入栈</code>:JVM会调用main方法,在栈中为main方法创建一个<code>栈帧</code>。栈帧中包含main方法的局部变量,如:stu。</li><li>对象创建:在main方法中,通过new关键字创建一个对象,那么这个对象被储存在堆中,对象中包含<code>name</code>,<code>age</code>,<code>sex</code>三个字段。</li><li>方法调用:调用<code>hello方法</code>时,JVM会在栈中为hello方法创建新的栈帧,并将控制权转移到hello方法中,在hello方法执行完毕后,栈帧会被弹出栈,控制权返回main方法。</li><li>方法结束:当main方法执行完毕后,栈帧会被弹出栈,程序结束。</li><li>stu变量内记录的是对象的地址,因此变量<code>stu也是引用类型的变量</code>。</li></ol><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>this关键字</code>是java中的一个引用变量,它通常指向当前变量。在一个类的方法或<code>构造器(构造函数)</code>内,this关键字可以用来引用调用该方法或构造器的<code>对象实例</code>。this代表当前正在执行操作的对象本身。<code>哪个对象调用的方法,this就指向哪个对象</code>。</p><h3 id="使用this区分成员变量与局部变量"><a href="#使用this区分成员变量与局部变量" class="headerlink" title="使用this区分成员变量与局部变量"></a>使用this区分成员变量与局部变量</h3><p>当方法或构造函数的<code>参数名</code>与<code>类的成员变量名</code>相同时,就会产生命名冲突,如果不加以区分,编辑器默认会使用局部变量(也就是参数),而不是成员变量,这可能会导致代码逻辑错误。通过<code>this</code>关键字可以明确指定要访问的是<code>类的成员变量</code>。这一点在<code>构造函数(构造器)</code>中常常被使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Student类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-comment">// 构造函数,函数名必须与方法名一致</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age,String sex)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,my name is &quot;</span>+<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;,i am &quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot; years old,i am a &quot;</span>+<span class="hljs-built_in">this</span>.sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 项目入口</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;男&quot;</span>);<br>        <span class="hljs-comment">// stu.name = &quot;小明&quot;;</span><br>        <span class="hljs-comment">// stu.age = 18;</span><br>        <span class="hljs-comment">// stu.sex = &quot;男&quot;;</span><br><br>        stu.hello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过在构造函数内使用<code>this</code>关键字,<code>this.name = name</code>来指定对象的属性值等于传入的参数值,这样就可以在实例化对象的时候直接通过传递参数的方式来给对象属性赋值,这就是<code>构造函数</code></p><h2 id="构造器-构造函数"><a href="#构造器-构造函数" class="headerlink" title="构造器(构造函数)"></a>构造器(构造函数)</h2><p>创建对象时,对象会调用构造函数。<code>new Student()</code>,<code>Student</code>是创建对象,<code>()</code>是用来调用构造函数的。每个类都有一个构造函数,即便程序员不写,系统也会分配一个默认的构造函数。</p><ol><li>构造函数可以有多个,类似于方法的重载。</li><li>构造函数没有返回值。</li><li>构造函数不需要手动调用,程序会自动帮忙调用。</li><li>构造函数名必须与类名保持一致。</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>继承的本质就是实现对共性的抽取,同时实现代码的复用。通过对事物抽象成为一个类,类内包含这一事物的属性与行为,继承就是将这一类事物的共同属性与行为抽取出来,当在定义术语这一类事物的类时可以直接使用。而<code>抽象类</code>是因为父类提供的信息不足以描述一个具体的类,因此将父类定义为抽象类,间接加上一层效验,防止在代码中使用父类创建并使用对象。但继承也有缺点,继承是对共性的抽取,不同的对象虽然同属于一个类,但各自都会有不同的个性。</p><p>比如:动物类,狗属于动物,鸟也属于动物。但狗会跑,鸟不会。鸟会飞,狗不会。这是两者的<code>个性</code>而非共性,因此<code>父类就无法含有行为跑与行为飞</code>。可以在定义狗类时,加上自己的<code>行为跑</code>,定义鸟类时,加上自己的行为飞。可是新的问题又出现了,如果在定义一个鸭子类呢,鸭子会跑也会飞,在鸭子类中继续定义行为跑与行为飞?<code>当定义的类多了,每个类有自己单独的行为,但不同类之间又有共性,那继承的本质何在?</code></p><p><code>接口</code>可以理解为<code>对外提供一组公共的行为规范标准</code>,只要当前实例化对象符合行为规范标准,就可以让当前类<code>实现这个接口</code>。比如:定义一个接口,是行为跑的标准,狗会跑,因此狗可以实现该接口,在定义一个接口,是行为飞标准,鸟与鸭子会飞,因此鸟与鸭子可以实现这个接口</p></blockquote><p>什么是接口?<br>    在Java中,<code>接口(interface)</code>是一种引用数据类型,但是它只能包含<code>常量,方法签名和嵌套类型</code>。接口不能包含实例变量或方法的实现(在Java8及以上的版本,可以定义默认方法与静态方法)。接口主要用于定义类的外部行为,并允许类实现这些行为。</p><h3 id="接口实现与使用"><a href="#接口实现与使用" class="headerlink" title="接口实现与使用"></a>接口实现与使用</h3><h4 id="定义接口语法"><a href="#定义接口语法" class="headerlink" title="定义接口语法"></a>定义接口语法</h4><p>接口的定义需使用<code>interface</code>关键字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 常量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">LEGS</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 默认有 &#x27;public static final&#x27;修饰词</span><br><br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 默认有修饰符&#x27;public abstract&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>一个类通过<code>implements</code>关键字来实现接口,并实现接口中所有的抽象方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现接口 &#x27;implements 接口名&#x27;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    <span class="hljs-comment">// 重写接口抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog类重写方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h4><p>通过接口引用实现类对象,可以实现<code>多态</code>性(有点类似于父类引用子类对象)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><br>        dog.makeSound();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><h4 id="方法共有性与抽象性"><a href="#方法共有性与抽象性" class="headerlink" title="方法共有性与抽象性"></a>方法共有性与抽象性</h4><p>接口中的方法都默认是public的,而且必须是public的,private和protected修饰符都不能在接口中使用。<code>接口中的所有方法都是public的,以便能够实现类访问</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 默认为public</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="变量默认为公有静态常量"><a href="#变量默认为公有静态常量" class="headerlink" title="变量默认为公有静态常量"></a>变量默认为<code>公有静态常量</code></h4><p>接口中定义的变量默认是<code>public static final</code>修饰的,及静态常量。所有实现该接口的类,都可以访问这些常量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        System.out.println(Dog.LEGS);<br>        System.out.println(Animal.LEGS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="不能被实例化"><a href="#不能被实例化" class="headerlink" title="不能被实例化"></a>不能被实例化</h4><p>接口<code>不能被实例化</code>,所以<code>不支持构造函数</code>。尝试在接口中写构造函数会出现报错。<br><code>Not allowed in interface</code></p><h4 id="默认方法和静态方法"><a href="#默认方法和静态方法" class="headerlink" title="默认方法和静态方法"></a>默认方法和静态方法</h4><ol><li>从Java8开始,接口可以包含<code>默认方法与静态方法</code>。</li><li><code>默认方法(default)</code>:默认方法可以有<code>方法体</code>。默认方法不需要实现接口类去实现,但它们仍然是public的,使用<code>default</code>关键词修饰的是默认方法,与访问修饰符无关。</li><li><code>静态方法(static)</code>:静态方法也有方法体,不需要实现接口的类实现,这些方法是public的,并且可以通过接口调用。使用static修饰。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 常量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">LEGS</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 默认有 &#x27;public static final&#x27;修饰词</span><br><br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 默认有修饰符&#x27;public abstract&#x27;</span><br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;eat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;static foo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对于<code>默认方法</code>,实现这个接口的类<code>可以重写</code>它</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现接口 &#x27;implements 接口名&#x27;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    <span class="hljs-comment">// 实现接口抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog类重写方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写默认方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog 在吃&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接口的抽象方法的实现"><a href="#接口的抽象方法的实现" class="headerlink" title="接口的抽象方法的实现"></a>接口的抽象方法的实现</h4><blockquote><p>一个普通类实现接口,需要将接口中的所有抽象方法实现,如果是抽象类实现接口,则是否实现抽象方法都行。</p></blockquote><h4 id="接口之间的继承"><a href="#接口之间的继承" class="headerlink" title="接口之间的继承"></a>接口之间的继承</h4><p>接口不能继承某个类,但<code>接口可以继承接口</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;static foo&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animals</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>Java接口支持<code>多重继承</code>,即一个接口可以继承自多个不同的接口。这与类的继承不同,类只支持单继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 常量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">LEGS</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 默认有 &#x27;public static final&#x27;修饰词</span><br><br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 默认有修饰符&#x27;public abstract&#x27;</span><br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;eat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;static foo&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InnerAnimal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo3</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 继承接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animals</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>,InnerAnimal&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo2</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="多重接口的实现"><a href="#多重接口的实现" class="headerlink" title="多重接口的实现"></a>多重接口的实现</h3><p>Java中,类本身无法多重继承(一个子类继承多个父类),但一个类可以实现多个接口,这样就实现了多重继承的效果。这种特殊性称为<code>多重接口实现</code>。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>一个类实现多个接口时,接口之间使用逗号分割。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现接口 &#x27;implements 接口名&#x27;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>,InnerAnimal&#123;<br>    <span class="hljs-comment">// 实现接口中的所有方法</span><br>&#125;<br></code></pre></td></tr></table></figure><br>实现多个接口时,类必须实现接口中定义的所有抽象方法。如果某个接口有<code>默认方法</code>,则可以<code>重写</code>它或<code>直接使用</code></p><h3 id="实现接口与继承性"><a href="#实现接口与继承性" class="headerlink" title="实现接口与继承性"></a>实现接口与继承性</h3><ol><li>继承单一性 VS 接口多实现</li></ol><p>继承性:Java中一个类只能继承一个父类,这是因为Java不支持多继承,以避免菱形继承问题。</p><p>实现接口:一个类可以实现多个接口,这允许Java类通过实现多个接口来模拟多重继承。</p><h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>抽象类</code>是用<code>abstract</code>关键字修饰的类。它<code>不能被实例化</code>,通常作为其他类的<code>父类(基类)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>&#123;<br>    <span class="hljs-comment">// 类体</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抽象类可以包含普通方法,抽象方法,属性…。</strong></p><p>抽象类的特点:</p><ol><li>抽象类不能直接创建对象,需要通过子类来创建对象</li><li>抽象类可以包含普通成员函数,构造函数,静态属性,属性,抽象方法…任意成员</li></ol><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>抽象方法使用<code>abstract</code>关键字修饰。<code>它没有方法体(即没有作用),必须由子类重写</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象方法 没有方法体</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakFa</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法没有方法体</span><br></code></pre></td></tr></table></figure><p><strong>抽象方法的特点：</strong></p><ol><li>抽象方法不能写主体<br> 抽象方法只能声明,没有实现</li><li>抽象方法不能被<code>final</code>,<code>private</code>,<code>static</code>修饰<ol><li><code>final</code>:抽象方法需要被子类重写,而<code>final</code>方法不能被重写</li><li><code>private</code>:抽象方法需要被子类访和实现,而<code>private</code>方法不能被子类访问</li><li><code>static</code>:抽象方法依赖于实例,而<code>static</code>方法不依赖于实例。</li></ol></li></ol><h3 id="抽象方法与抽象类的关系"><a href="#抽象方法与抽象类的关系" class="headerlink" title="抽象方法与抽象类的关系"></a>抽象方法与抽象类的关系</h3><ol><li><p>抽象方法只能写在抽象类中</p><p> 如果一个类包含抽象方法,则这个类必须为抽象类。因为如果一个类包含抽象方法,那么这个类无法提供完整的实现,因此不能直接实例化,而<code>class 类名</code>的意思是可以实例化。</p></li><li><p>抽象方法可以没有抽象类</p><p> 抽象类可以不包含抽象方法,但任然不能实例化。</p></li></ol><h3 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h3><p>当一个类继承抽象类时,必须<code>实现抽象类中的所有抽象方法</code>,或者将自己也声明为抽象类。</p><ol><li><p>实现所有抽象方法,子类必须实现父类中的所有抽象方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>&#123;<br>    <span class="hljs-comment">// 抽象方法 没有方法体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakFa</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法没有方法体</span><br>&#125;<br><br><span class="hljs-comment">// 继承抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Son</span> &#123;<br><br>    <span class="hljs-comment">// 重写抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakFa</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;你好&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>声明抽象类,如果子类没有实现父类的所有抽象方法,那么子类也必须声明为抽象类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>&#123;<br>    <span class="hljs-comment">// 抽象方法 没有方法体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakFa</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法没有方法体</span><br>&#125;<br><br><span class="hljs-comment">// 继承抽象类 </span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Son</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="抽象类vs接口"><a href="#抽象类vs接口" class="headerlink" title="抽象类vs接口"></a>抽象类vs接口</h3><div class="table-container"><table><thead><tr><th>特性</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>关键字</td><td><code>abstract class</code></td><td><code>interface</code></td></tr><tr><td>实例化</td><td>无法实例化</td><td>无法实例化</td></tr><tr><td>方法实现</td><td>可以包含普通方法与抽象方法</td><td>Java8之前只能包含抽象方法</td></tr><tr><td>多继承</td><td>不支持(单继承)</td><td>支持(多实现)</td></tr><tr><td>构造器</td><td>可以有构造器</td><td>不能有构造器</td></tr><tr><td>成员变量</td><td>可以是普通变量</td><td>只能是常量(public static final)</td></tr><tr><td>设计目的</td><td>代码复用和层次设计</td><td>定义规范和扩展功能</td></tr></tbody></table></div><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>什么是内部类?<strong><em>在一个类的里面在定义一个类,就称为内部类</em></strong></p><blockquote><p>需要写一个类,描述一辆汽车。属性有车的品牌,车龄,颜色,发动机品牌以及使用年限。</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123; <span class="hljs-comment">// 外部类</span><br>String carName;<br><span class="hljs-type">int</span> carAge;<br>String color;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>&#123; <span class="hljs-comment">// 内部类</span><br>        String engineName;<br>        <span class="hljs-type">int</span> engineAge;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>1. 内部类表示的是外部类的一部分2. 内部类单独出现没有任何意义</code></pre></blockquote><p>内部类的访问特点</p><pre><code class="hljs">1. 内部类可以直接访问外部类的成员,包括私有2. 外部类要访问内部类的成员,必须创建对象</code></pre><h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><blockquote><p>写在成员位置的内部类<br>内部类方法中获取外部类中的重名成员变量<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123; <span class="hljs-comment">// 外部类</span><br>    String carName;<br>    <span class="hljs-type">int</span> carAge;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span>;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>&#123; <span class="hljs-comment">// 内部类</span><br>        String engineName;<br>        <span class="hljs-type">int</span> engineAge;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yellow&quot;</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;orange&quot;</span>;<br>            System.out.println(color); <span class="hljs-comment">// orange</span><br>            System.out.println(<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// yellow</span><br>            System.out.println(Car.<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// red</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类中只能访问<code>外部类中的静态变量与静态方法</code>,如果想要访问非静态的需要创建对象访问</p><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>将内部类定义在<code>方法内</code>,就叫做局部内部类</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础】数组与方法</title>
      <link href="/2025/03/22/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
      <url>/2025/03/22/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数据就是一个容器,可以存储<code>同种数据类型</code>的<code>多个值</code>。</p><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><ol><li><p>第一种格式:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据类型[] 数组名 = new 数据类型[数组长度]; </span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure></li><li><p>第二种格式:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> arr[] <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure></li><li><p>数组长度默认可以省略不写。</p></li></ol><h3 id="数组的静态初始化"><a href="#数组的静态初始化" class="headerlink" title="数组的静态初始化"></a>数组的静态初始化</h3><ol><li><p>完整格式</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = <span class="hljs-keyword">new</span> 数据类型[数组长度]&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3.</span>..&#125;;<br></code></pre></td></tr></table></figure></li><li><p>简化格式</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = &#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3.</span>..&#125;;<br></code></pre></td></tr></table></figure></li><li><p>实例</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建数组,存储学生年龄</span><br><span class="hljs-type">int</span>[] ageArr = &#123;<br>    <span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h3 id="数组中的元素"><a href="#数组中的元素" class="headerlink" title="数组中的元素"></a>数组中的元素</h3><ol><li><p>如果直接使用System.out.println()直接打印数组,会输出数组的地址值<code>[I@54bedef2</code>,而不是数组中的元素。</p><ol><li><code>[</code>表示数组的类型</li><li><code>I</code>表示数组的元素类型是int</li></ol></li><li><p>获取数组的元素</p><p> 格式:数组名[索引] 数组中的索引是从0开始的。</p></li><li><p>将数据存储到数组中</p><p> 格式:数组名[索引] = 数据/变量 // 数据会覆盖原来的值</p></li><li><p>数组的遍历</p><p> 遍历指依次取出数组中的所有元素。<code>ageArr.length</code>表示数组的长度。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ageArr.length; i++)&#123;<br>    System.out.println(ageArr[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组其实就是一维数组内部的每个元素又是一个一维数组。也就是一维数组内部又嵌套着一维数组。</p><h3 id="二维数组的声明"><a href="#二维数组的声明" class="headerlink" title="二维数组的声明"></a>二维数组的声明</h3><ol><li><code>int[][] arr;</code></li><li><code>int arr[][];</code></li><li><code>int[] arr[];</code></li><li><code>int[] a,b[];</code>:这样声明a是一维数组,b是二维数组。</li></ol><h3 id="二维数组的创建"><a href="#二维数组的创建" class="headerlink" title="二维数组的创建"></a>二维数组的创建</h3><ol><li><p>静态初始化(定义的同时赋值):</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;;<br></code></pre></td></tr></table></figure></li><li><p>动态初始化</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure></li></ol><p>因为int类型默认值为0,所以输出值全部为0。这种方式相比之前还是比较灵活的,可以通过用户<code>自行输入数组内的值</code>。</p><h3 id="二维数组的遍历与输出"><a href="#二维数组的遍历与输出" class="headerlink" title="二维数组的遍历与输出"></a>二维数组的遍历与输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;;<br><br><span class="hljs-comment">// 第一层循环遍历外层数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>    <span class="hljs-comment">// 第二层循环遍历内层数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arr[i].length;j++)&#123;<br>        <span class="hljs-comment">// 打印每一个值</span><br>        System.out.println(arr[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>方法是程序中最小的执行单元。重复的代码或有独立功能的代码抽取到方法中。</strong></p><h3 id="定义与调用方法"><a href="#定义与调用方法" class="headerlink" title="定义与调用方法:"></a>定义与调用方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">playGame</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>    <span class="hljs-comment">// 返回值</span><br>    <span class="hljs-keyword">return</span> x,y;<br>&#125; <br><br><span class="hljs-comment">// 调用方法</span><br>playGame(x,y);<br></code></pre></td></tr></table></figure><p>参数与返回值可以不写。注意:方法在调用时,参数的数量与类型必须与定义时一致,否则就会出现语法错误。</p><ol><li><p>形参与实参:</p><p> 方法定义中的参数称为<code>形参</code>,方法调用时的参数称为<code>实参</code>。</p></li><li><p><code>void</code>表示无返回值类型,当方法需要返回值时,将void替换为<code>返回值的类型</code>即可</p></li></ol><h2 id="方法重载-Overload"><a href="#方法重载-Overload" class="headerlink" title="方法重载(Overload)"></a>方法重载(Overload)</h2><p>方法重载是Java中实现多态的一种方式,它允许在同一个类中定义多个<code>同名的方法</code>,只要这些方法的参数列表不同。这些不同的参数列表可以通过不同的<code>参数类型</code>,<code>参数数量</code>和<code>参数顺序</code>来实现。使用<code>println()</code>方法打印不同的数据类型,就是利用的方法重载。</p><h3 id="重载的条件"><a href="#重载的条件" class="headerlink" title="重载的条件:"></a>重载的条件:</h3><p>重载的条件是方法名相同,参数列表不同(<code>参数数量</code>,<code>参数类型</code>,参数顺序[参数顺序一般不用])。</p><h3 id="重载实现"><a href="#重载实现" class="headerlink" title="重载实现:"></a>重载实现:</h3><ol><li><p>参数<code>类型不同</code>:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据传递的参数类型不同,调用不同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>参数<code>数量不同</code>:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据传递的参数数量不同,调用不同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>参数<code>顺序不同</code>:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据传递的参数顺序不同,调用不同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">double</span> b,<span class="hljs-type">int</span> a)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>重载的优点:</p><ol><li>提高代码可读性:使用相同的方法名称,有助于统一语义,增强代码可读性。</li><li>灵活性与简洁性:根据不同的参数进行不同的处理,增强代码的灵活性与简洁性。</li></ol></li><li><p>重载注意事项:</p><ol><li>方法返回值类型不同不能作为重载依据:方法重载与返回类型无关,只看参数列表</li><li>参数名称不同:不能作为重载依据,方法重载与参数名称无关。</li><li>方法修饰符无关:访问修饰符(public,private…)不影响方法重载。</li><li>抛出异常无关:方法抛出的异常类型与数量不会影响方法重载。</li></ol></li></ol><h2 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h2><ol><li>栈:方法运行时使用的内存,比如main方法运行。</li><li>堆:存储对象或数组,new出来的都存储在堆中。</li><li>方法区:存储可以运行的class文件</li><li>本地方法栈:JVM在使用操作系统时使用,与程序员基本无关。</li><li>寄存器:给CPU使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础】各种语句</title>
      <link href="/2025/03/22/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%90%84%E7%A7%8D%E8%AF%AD%E5%8F%A5/"/>
      <url>/2025/03/22/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%90%84%E7%A7%8D%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2><ol><li><p>运算符：对字面量或者变量进行操作的字符,如：<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>。</p></li><li><p>表达式：用运算符把字面量或者变量连接起来符合java语法的式子,如：<code>a + b</code>。</p></li></ol><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><div class="table-container"><table><thead><tr><th>符号</th><th>作用</th><th>表达式</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>1 + 2</td></tr><tr><td>-</td><td>减</td><td>1 - 2</td></tr><tr><td>*</td><td>乘</td><td>1 * 2</td></tr><tr><td>/</td><td>除</td><td>10 / 3(整数参与计算,结果只能是整数)</td></tr><tr><td>%</td><td>取余/取模</td><td>1 % 2</td></tr><tr><td>++</td><td>自增</td><td>1++</td></tr><tr><td>—</td><td>自减</td><td>1—</td></tr></tbody></table></div><p><strong>在算数中如果有小数参与计算,结果有可能<code>不精确</code></strong></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>类似<code>+=</code>表示把左边与右边的数据相加,然后重新赋值给左边。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;b = <span class="hljs-number">20</span>;<br>a += b; <span class="hljs-comment">// a = 30</span><br></code></pre></td></tr></table></figure><p><strong><code>+=,-=,*=,/=,%=</code>它们的底层都隐藏了一个强制类型转换。</strong></p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>==</td><td>判断左右两边是否相等</td></tr><tr><td>!=</td><td>判断左右两边是否不相等</td></tr><tr><td>&gt;</td><td>判断左边是否大于右边</td></tr><tr><td>&lt;</td><td>判断左边是否小于右边</td></tr><tr><td>&gt;=</td><td>判断左边是否大于等于右边</td></tr><tr><td>&lt;=</td><td>判断左边是否小于等于右边</td></tr></tbody></table></div><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol><li>&amp; - 逻辑与(全为true,则满足条件)</li><li>| - 逻辑或(一个为true,则满足条件)</li><li>! - 逻辑非/<code>取反</code>(true为false,false为true)</li><li>^ - 逻辑异或(相同为false,不同为true)</li></ol><h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><p>短路逻辑运算符<code>效率比普通的逻辑运算符高</code></p><ol><li>&amp;&amp; - 短路与(左边为false,则右边不执行)</li><li>|| - 短路或(左边为true,则右边不执行)</li></ol><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>三元运算符可以用来处理简单的判断,根据判断的结果得到不同的内容。</p><p>格式： 关系表达式 ? 表达式1 : 表达式2 (true执行表达式1,false执行表达式2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> num1 &gt; num2 ? num1 : num2;<br><span class="hljs-comment">// 表达式为true返回num1,false返回num2</span><br></code></pre></td></tr></table></figure><h2 id="隐式转换与强制转换"><a href="#隐式转换与强制转换" class="headerlink" title="隐式转换与强制转换"></a>隐式转换与强制转换</h2><h3 id="隐式转换-自动类型提升"><a href="#隐式转换-自动类型提升" class="headerlink" title="隐式转换(自动类型提升)"></a>隐式转换(自动类型提升)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a; <span class="hljs-comment">// b = 10.0 隐式转换</span><br></code></pre></td></tr></table></figure><ol><li><p>取值范围小的数据与取值范围大的数据进行计算时,范围小的会优先转换为范围大的数据,然后进行计算(byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double)。</p></li><li><p>byte, short, char(ASCLL码表)三种数据类型进行计算时,都会先直接转换为int类型,然后在进行计算。</p></li></ol><h3 id="强制类型转换-强制将一个数据类型转换为另一个数据类型。"><a href="#强制类型转换-强制将一个数据类型转换为另一个数据类型。" class="headerlink" title="强制类型转换:强制将一个数据类型转换为另一个数据类型。"></a>强制类型转换:强制将一个数据类型转换为另一个数据类型。</h3><p>格式：目标数据类型 变量名 = (目标数据类型)被强转的数据;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">12.3</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)a; <span class="hljs-comment">// b为12,强制转换数据会溢出,甚至发生数据错误</span><br></code></pre></td></tr></table></figure><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>当<code>+</code>出现字符串时,这个<code>+</code>将不会作为算数运算符,而是用作<code>字符串的拼接</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str + num; <span class="hljs-comment">// result = &quot;hello123&quot;;</span><br></code></pre></td></tr></table></figure><h2 id="字符相加"><a href="#字符相加" class="headerlink" title="字符相加"></a>字符相加</h2><p>当字符与<code>字符</code>或者<code>数字</code>相加时,字符会被转换为<code>ASCLL码表</code>的值进行相加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">0</span>; result = <span class="hljs-number">97</span><br></code></pre></td></tr></table></figure><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><pre><code class="hljs">顺序结构是java中默认的执行流程,按照代码顺序,从上到下依次执行。</code></pre><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if语句在程序中就是用来专门判断的。如果条件满足,则执行if语句体中的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">// 进行判断</span><br><span class="hljs-keyword">if</span>(age &gt; <span class="hljs-number">18</span>)&#123;<br>    <span class="hljs-comment">// 语句体</span><br>    System.out.println(<span class="hljs-string">&quot;你以成年&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(age == <span class="hljs-number">18</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;你刚成年&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 如果条件都不满足,则执行else语句体</span><br>    System.out.println(<span class="hljs-string">&quot;未成年&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果语句体中,只有一句代码,<code>大括号可以省略不写</code>。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p><code>switch</code>语句与if语句差不多,需要注意的是,switch的匹配中是表达式的值,而不是一个条件,case后面的值<code>只能是字面量</code>,不能是变量,并且不能重复。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式:"></a>语法格式:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-comment">// case中能写多个匹配的值,用逗号隔开</span><br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>, 值<span class="hljs-number">0</span>:<br>        语句体<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>        语句体<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        语句体n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="default的位置和省略："><a href="#default的位置和省略：" class="headerlink" title="default的位置和省略："></a>default的位置和省略：</h4><p>如果<code>default</code>省略了,则如果匹配不上,则没有任何语句可以执行。default的位置其实可以放在任何位置,但是平时都会放在最下面</p><h4 id="case穿透："><a href="#case穿透：" class="headerlink" title="case穿透："></a>case穿透：</h4><p>如果<code>break</code>省略,就会导致case穿透,break是用来结束case语句的,如果不写,case语句体执行完以后会继续往下执行。这像程序员的疏忽,但有时候也可以使用这种方式简化代码,使用场景很少。</p><h4 id="switch新特性"><a href="#switch新特性" class="headerlink" title="switch新特性"></a>switch新特性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(number)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;星期一&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;星期二&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">default</span> -&gt; System.out.println(<span class="hljs-string">&quot;其他&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这是java中switch的新写法,不需要写break也不会造成<code>case穿透</code>现象。</p><h4 id="switch与if"><a href="#switch与if" class="headerlink" title="switch与if"></a>switch与if</h4><ol><li>if一般用于对<code>范围</code>的判断</li><li>switch一般用于对<code>多个值</code>进行判断</li></ol><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化语句;条件判断语句;条件控制语句)&#123;<br>    循环体;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环与for循环基本一致。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">10</span>)&#123;<br>    <span class="hljs-comment">// 语句体</span><br><br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for循环与while循环的区别"><a href="#for循环与while循环的区别" class="headerlink" title="for循环与while循环的区别"></a>for循环与while循环的区别</h4><ol><li>for循环在知道循环次数或者循环范围的情况下使用。</li><li>while循环在不知道循环次数,不知道循环范围,只知道循环结束条件的情况下使用。</li></ol><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化语句<br><span class="hljs-keyword">do</span>&#123;<br>    循环体;<br>&#125;<span class="hljs-keyword">while</span>(条件判断)<br></code></pre></td></tr></table></figure><p>do…while会先执行一次循环才会判断条件,即使条件是false也会先执行一遍。</p><h3 id="结束循环"><a href="#结束循环" class="headerlink" title="结束循环"></a>结束循环</h3><ol><li>break结束<code>整个循环</code></li><li>continue结束本次循环,进入下次循环。</li></ol><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>java有一个内置类Random,可以生成随机数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 导包</span><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>        <span class="hljs-comment">// 生成随机数,nextInt内写入随机数的范围</span><br>        <span class="hljs-comment">// 从0开始生成到10的随机数,不包括10</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="数字6-if判断"><a href="#数字6-if判断" class="headerlink" title="数字6(if判断)"></a>数字6(if判断)</h3><p>键盘录入两个数字，如果其中一个是数字6,则输出true，如果它们的和为6的倍数,则输出true，其他情况则输出false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/* 键盘录入两个数字</span><br><span class="hljs-comment">         * 如果其中一个是数字6,则输出true</span><br><span class="hljs-comment">         * 如果它们的和为6的倍数,则输出true</span><br><span class="hljs-comment">         * 其他情况则输出false</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        System.out.println(<span class="hljs-string">&quot;请输入第一个数字&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        System.out.println(<span class="hljs-string">&quot;请输入第二个数字&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">// 判断</span><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">6</span> || num2 == <span class="hljs-number">6</span> || ((num + num2)%<span class="hljs-number">6</span> == <span class="hljs-number">0</span>) )&#123;<br>            System.out.println(<span class="hljs-string">&quot;true&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;false&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="商品的价格-if判断"><a href="#商品的价格-if判断" class="headerlink" title="商品的价格(if判断)"></a>商品的价格(if判断)</h3><p>一件商品总价为1000元,假设用户为一级会员,那么就打9折,二级会员打8折,三级会员打7折,剩余的不打折。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 总价</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">// 输入vip等级</span><br>        System.out.println(<span class="hljs-string">&quot;请输入您的VIP等级&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">vip</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-keyword">if</span>(vip == <span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;您是一级vip,你购买的价格是:&quot;</span> + price * <span class="hljs-number">0.9</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vip == <span class="hljs-number">2</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;您是二级vip,您购买的价格是:&quot;</span> + price * <span class="hljs-number">0.8</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vip == <span class="hljs-number">3</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;您是三级vip,您购买的价格是:&quot;</span> + price * <span class="hljs-number">0.7</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;您不是vip客户,您购买的价格是:&quot;</span> + price);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运动计划-switch"><a href="#运动计划-switch" class="headerlink" title="运动计划(switch)"></a>运动计划(switch)</h3><p>键盘录入星期数,显示当天的运动计划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 键盘录入星期数</span><br>        System.out.println(<span class="hljs-string">&quot;请输入星期几:&quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">week</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-keyword">switch</span>(week)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                System.out.println(<span class="hljs-string">&quot;跑步&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                System.out.println(<span class="hljs-string">&quot;游泳&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                System.out.println(<span class="hljs-string">&quot;慢走&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                System.out.println(<span class="hljs-string">&quot;动感单车&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                System.out.println(<span class="hljs-string">&quot;拳击&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                System.out.println(<span class="hljs-string">&quot;爬山&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>                System.out.println(<span class="hljs-string">&quot;好好吃一顿&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for循环打印数字-for循环"><a href="#for循环打印数字-for循环" class="headerlink" title="for循环打印数字(for循环)"></a>for循环打印数字(for循环)</h3><p>循环打印1-5与5-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-comment">// 输出1-5</span><br>            System.out.println(i);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">5</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>            <span class="hljs-comment">// 输出5-1</span><br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="断线重连-for循环"><a href="#断线重连-for循环" class="headerlink" title="断线重连(for循环)"></a>断线重连(for循环)</h3><p>循环断线重连5次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 现在我们处于断线状态，需要重新连接</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isWeb</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span>+ i +<span class="hljs-string">&quot;重连中...&quot;</span>);<br><br>            <span class="hljs-keyword">if</span>(isWeb)&#123;<br>                System.out.println(<span class="hljs-string">&quot;连接成功,继续进行游戏&quot;</span>);<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;重连失败,正在进行下次重连&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统相关操作</title>
      <link href="/2025/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td><code>Win</code> + <code>E</code></td><td>此电脑</td></tr></tbody></table></div><h2 id="打开CMD窗口"><a href="#打开CMD窗口" class="headerlink" title="打开CMD窗口"></a>打开CMD窗口</h2><ol><li><p>按下键盘上的 <code>Win</code> + <code>R</code> 键</p></li><li><p>在左下角运行菜单输入<code>cmd</code></p></li><li><p>按下回车，打开<code>CMD窗口</code></p></li></ol><h2 id="常见CMD指令"><a href="#常见CMD指令" class="headerlink" title="常见CMD指令"></a>常见CMD指令</h2><div class="table-container"><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>盘符+冒号</td><td>盘符切换</td></tr><tr><td>dir</td><td>查看当前目录下的内容(包括<code>隐藏的内容</code>)</td></tr><tr><td>CD目录</td><td>进入目录　</td></tr><tr><td>cd\目录1\目录2</td><td>进入多级目录</td></tr><tr><td>CD..</td><td>退出当前目录</td></tr><tr><td>cd\</td><td>退回盘符目录</td></tr><tr><td>cls</td><td>清理控制台</td></tr><tr><td>exit</td><td>退出命令提示窗口</td></tr></tbody></table></div><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置<code>环境变量</code></h2><p>想要在所有的路径下，都能打开指定的软件或者文件，或者其他的程序，就需要在环境变量中配置地址。</p><ol><li><p>按 <code>Win</code> + <code>E</code> 键，打开<code>此电脑</code>。</p></li><li><p>点击<code>属性</code>，点击<code>高级系统设置</code>，点击<code>环境变量</code>。</p></li><li><p>双击<code>Path</code>系统变量，将要记录的软件地址，输入到里面。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web前端开发学习路线</title>
      <link href="/2025/03/15/Web/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2025/03/15/Web/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搞技术的，就是靠技术吃饭。有技术，工资高。没技术，工资低。</p></blockquote><h2 id="HTML-CSS-JavaScript"><a href="#HTML-CSS-JavaScript" class="headerlink" title="HTML/CSS/JavaScript"></a>HTML/CSS/JavaScript</h2><p>第一阶段,学习前端,<code>前端三剑客</code>肯定得学,学完前端三剑客以后,也只是入门阶段而已。</p><h2 id="前端库"><a href="#前端库" class="headerlink" title="前端库"></a>前端库</h2><p>比如：<code>jQuery</code>,<code>Bootstrap</code>,移动端开发之类的。让网页开发可以更快,更高效。</p><h2 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h2><p><code>mongoDB数据库</code>就是为前端而生的,很适合用来做为网页的数据库。</p><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p><code>Node.js</code>可以让js脱离浏览器,在服务端运行。</p><h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><p><code>mongoose</code>只是一个node.js开发库,能将node.js与mongoDB连接起来。</p><h2 id="koa-express"><a href="#koa-express" class="headerlink" title="koa/express"></a>koa/express</h2><p><code>koa</code>/<code>express</code>都是node.js开发框架,可以快速搭建web服务。</p><p>有了这些就可以将前端,数据库,服务器连接起来,就是一个真正的网站了。</p><h2 id="webpack-vite打包工具"><a href="#webpack-vite打包工具" class="headerlink" title="webpack/vite打包工具"></a>webpack/vite打包工具</h2><p><code>webpack</code>/<code>vite</code>都是前端打包工具,可以将js,css,图片等文件打包成一个文件。</p><h2 id="前端三大框架"><a href="#前端三大框架" class="headerlink" title="前端三大框架"></a>前端三大框架</h2><p><code>React</code>,<code>Vue</code>,<code>Angular</code>都是前端框架,可以帮助我们快速开发网页。以及<code>SPA单页面应用</code>。</p><h2 id="小程序-副业"><a href="#小程序-副业" class="headerlink" title="小程序(副业)"></a>小程序(副业)</h2><p>不是特别重要</p><h2 id="git-github"><a href="#git-github" class="headerlink" title="git/github"></a>git/github</h2><p>版本控制工具,可以帮助我们管理代码。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>可以学习学习<code>java</code>以及<code>MySQL</code>,这样就可以往全栈方向发展了。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础】一些基本的简单语法</title>
      <link href="/2025/03/14/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/14/Java/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ol><li>VSCode(需要配置java环境) </li></ol><h2 id="JDK下载与安装"><a href="#JDK下载与安装" class="headerlink" title="JDK下载与安装"></a>JDK下载与安装</h2><ol><li><p>JDK下载地址:<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p></li><li><p>傻瓜式下一步安装即可(安装地址建议就使用默认的,C盘也不缺那点内存,这种程序安装地址修改了的话,后面的坑太多了)</p></li></ol><p><strong>安装好之后,可以在安装地址找到<code>java/jdk</code>目录,其中:</strong></p><ol><li><p><code>bin</code>: 存放各种工具命令,如：<code>javac</code>,<code>java</code></p></li><li><p>conf: 存放相关配置文件</p></li><li><p>include: 存放一些平台特定头文件</p></li><li><p>jmods: 存放各种模块</p></li><li><p>legal: 存放各种模块授权文档</p></li><li><p>lib: 存放各种工具补充JAR包</p></li></ol><h2 id="HELLO-WORLD"><a href="#HELLO-WORLD" class="headerlink" title="HELLO WORLD"></a>HELLO WORLD</h2><p><strong>所有编程语言的开头都是<code>HELLO WORLD</code>,写个HelloWorld爽一下</strong></p><ol><li><p>先创建一个<code>HelloWorld.java</code>文件,java文件的后缀是<code>.java</code></p></li><li><p>编写HelloWorld代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类名与文件名保持一致</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123;<br>    <span class="hljs-comment">// 入口函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">// 输出Hello World</span><br>        System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>运行原理：</p></li></ol><p>当java文件运行时,<code>bin</code>目录内的<code>javac</code>工具会首先编译文件为<code>HelloWorld.class</code>文件,然后java工具才会运行<code>.class</code>文件,运行时是不加后缀的。</p><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><ol><li><p>所有标点符号必须是英文状态下的</p></li><li><p>java内大小写严格,该大写的地方大写,该小写的地方小写。</p></li><li><p>关键词别写错了,语法不能有错误。</p></li></ol><h2 id="JAVA可以干什么"><a href="#JAVA可以干什么" class="headerlink" title="JAVA可以干什么?"></a>JAVA可以干什么?</h2><ol><li><p>Java SE：标准版。用于左面/应用开发,是其他版本的基础(桌面应用 || C/C++)。</p></li><li><p>Java ME：小型版。嵌入式电子设备/小型移动设备(嵌入式)—<code>差不多凉</code>。</p></li><li><p>Java EE：专业版。web方向的网站开发(Web网站开发<code>[浏览器&amp;服务器]</code>)。</p></li></ol><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol><li><p>面向对象：简单来说就是,根据用户想要的功能，设计出符合用户需求的对象。</p></li><li><p>安全性</p></li><li><p>多线程：同时做多件事</p></li><li><p>开源</p></li><li><p>跨平台：window || mac || linux</p></li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li><p>单行注释：<code>//</code></p></li><li><p>多行注释：<code>/* */</code></p></li><li><p>文档注释：<code>/** */</code></p></li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>创建变量时,需要在内存中申请存储空间,内存管理系统根据变量类型为变量分配空间,所以申请的空间只能存储<code>对应类型的数据</code>。</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>关键词</th><th>描述</th></tr></thead><tbody><tr><td>整数</td><td>byte(-128~127),short,int,long(L后缀)</td><td>666,-123</td></tr><tr><td>小数(浮点数)</td><td>float(F后缀),double</td><td>6.66,-12.33</td></tr><tr><td>字符串(<code>需要用双引号包裹</code>)</td><td>string</td><td>“helloworld”,”hjk”</td></tr><tr><td>字符(<code>只能用单引号包裹</code>)</td><td>char</td><td>‘a’,’b’</td></tr><tr><td>布尔值</td><td>boolean</td><td>true/false</td></tr><tr><td>空值</td><td>void</td><td>null</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xiaohu&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br><br>        System.out.println(name);<br>        System.out.println(age);<br>        System.out.println(sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在程序中存储数据的容器。</p><ol><li><p>声明变量：</p><p> 数据类型 变量名 = 值;</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(a); <span class="hljs-comment">// 输出10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>参与计算：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 变量名不能重复</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        System.out.println(a + b);<br>        System.out.println(a - b);<br>        System.out.println(a * b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意</p><ol><li>变量名不能重复</li><li>变量可以重新赋值</li><li>变量在使用前要进行<code>赋值</code></li><li>变量要在<code>作用域内</code>使用</li></ol></li></ol><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符就是程序员给类,方法,变量取的名字。JAVA中的命名规范。</p><ol><li>硬性要求<ol><li>由<code>数字,字母,下划线,$</code>组成</li><li>不能以数字开头</li><li>不能是关键字</li><li>严格区分大小写</li></ol></li><li>君子协议<ol><li><code>方法或变量名</code>使用<code>小驼峰</code>命名法(多个单词组成,第二个单词首字母大写)</li><li><code>类名</code>使用<code>大坨峰</code>名命名法(每个单词首字母大写)</li></ol></li></ol><h2 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h2><p>监听用户的键盘输入。</p><p>Java有一个内置类(<code>Scanner</code>),可以接收键盘输入的<code>数字</code>。</p><ol><li><p>导包…找到Scanner类在哪</p></li><li><p>创建实例对象</p></li><li><p>接收数据</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 导包 -- 必须在类定义的上边</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 定义类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建实例对象</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 使用sc实例对象接收数据,将数据赋值给i</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">// 打印i</span><br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>sc.nextInt()：接收一个整数。</li><li>sc.nextDouble()：接收一个小数。</li><li>sc.next()：接收一个字符串。</li></ol><h2 id="键盘输入两个数字-并求和"><a href="#键盘输入两个数字-并求和" class="headerlink" title="键盘输入两个数字,并求和"></a>键盘输入两个数字,并求和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 导包 -- 必须在类定义的上边</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 定义类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个实例</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 录入第一个数字</span><br>        System.out.println(<span class="hljs-string">&quot;请输入第一个数字&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">// 录入第二个数字</span><br>        System.out.println(<span class="hljs-string">&quot;请输入第二个数字&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">// 输出和</span><br>        System.out.println(a + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在VSCode中创建java项目"><a href="#在VSCode中创建java项目" class="headerlink" title="在VSCode中创建java项目"></a>在VSCode中创建java项目</h2><ol><li><p>进入终端输入一下内容,检查电脑内是否安装 java</p> <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">java -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure></li><li><p>安装插件<code>Extension Pack for Java</code></p></li><li><p>创建一个项目</p><ol><li>创建一个文件夹,在VSCode内,点击菜单栏的<code>查看</code>,点击<code>命令面板</code>,输入<code>java</code>或者直接<code>CTRL</code> + <code>Shift</code> + <code>P</code> ,输入<code>java</code></li><li>选择创建<code>java项目(create java project)</code></li><li>选择要创建什么样的java项目,一般情况下<code>Maven</code>/<code>Spring Boot</code>比较多,当然也可以什么都不选</li><li>然后输入创建的项目文件夹</li><li>输入项目名</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES5与ES6的区别</title>
      <link href="/2025/03/01/JavaScript/ES5%E4%B8%8EES6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/03/01/JavaScript/ES5%E4%B8%8EES6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="　什么是ES6?"></a>　什么是ES6?</h2><blockquote><p>ES6是 JavaScript 的第六个主要版本标准，于 2015 年发布，带来了许多革命性的语法改进和新特性。以下是其核心特性：</p></blockquote><h2 id="let-和-const-关键字"><a href="#let-和-const-关键字" class="headerlink" title="let 和 const 关键字"></a><code>let</code> 和 <code>const</code> 关键字</h2><ol><li><p>作用：</p><p> ES6中引入了<code>let</code>和<code>const</code>来声明变量,并为它们提供了块级作用域（就相当于局部作用域）,解决了var变量声明的问题。</p></li><li><p>比较：</p><ul><li><code>let</code>：<br>  声明变量,并且可以修改变量的值</li><li><code>const</code>：<br>  声明常量,也就是无法修改变量的值</li></ul></li><li><p>底层实现原理：</p><p> JavaScript引擎对变量作用域链进行了优化,使<code>let</code>与<code>const</code>只能在指定作用域内使用。</p></li><li><p>使用</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;小明&#x27;</span><br>name = <span class="hljs-string">&#x27;小红&#x27;</span><br><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span><br><span class="hljs-comment">// age = 20 // 报错</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol><li><p>作用：</p><p> 绑定语法,同时自动绑定this到上下文,避免出现一些错误</p></li><li><p>使用场景：</p><p> 适用于较小的回调,事件处理,特别在处理异步是非常方便</p></li><li><p>底层实现原理：</p><p> 箭头函数没有自己的this,而是继承上下文作用域中的this指向</p></li><li><p>使用：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;箭头函数&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ol><li><p>作用：</p><p> 通过反引号 ` ,包裹字符串,并在其中写入表达式,可以更方便的拼接字符串。</p></li><li><p>使用场景：</p><p> 当需要构建复杂的HTML字段,SQL查询或其他多行文本时,很有用</p></li><li><p>底层实现原理：</p><p> 通过编译器解析成字符串片段和插值表达式,然后按照顺序连接</p></li><li><p>使用：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好,<span class="hljs-subst">$&#123;name&#125;</span>!`</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="　解构赋值"></a>　解构赋值</h2><ol><li><p>作用：</p><p> 直接从数组或者对象中提取值,并赋值给变量</p></li><li><p>使用场景：</p><p> 快速从API响应或其他数据源抽取所需数据,也可以用来交换两个变量的值</p></li><li><p>底层实现原理：</p><p> 解构赋值基于模式匹配,javascript引擎会根据提供的模式自动分配相应的值</p></li><li><p>使用：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">// 数组解构</span><br><span class="hljs-keyword">const</span> &#123;name, age&#125; = user; <span class="hljs-comment">// 对象解构</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><ol><li><p>作用：</p><p> 允许在函数定义时设置默认参数,当调用时没有传递参数&lt;就会使用默认参数</p></li><li><p>使用场景：</p><p> 减少不必要的条件判断</p></li><li><p>底层实现原理：</p><p> 默认参数在函数内部进行初始化检查,如果没有传递参数,或者传入的是undefined,就会使用默认参数</p></li><li><p>使用：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b = <span class="hljs-number">0</span></span>) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><ol><li><p>作用：</p><p> 将数组或对象拆分为独立元素,剩余参数收集到一个数组中</p></li><li><p>使用场景：</p><p> 合并数组或对象,传递参数等</p></li><li><p>底层实现原理：</p><p> 通过对现有数据结构的操作来实现</p></li><li><p>使用：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [...oldArr, newItem]; <span class="hljs-comment">// 数组合并</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol><li><p>作用：</p><p> 虽然ES6的类只是语法糖,但依然可以定义构造函数与方法</p></li><li><p>使用场景：</p><p> 构建大型项目时,有助于代码复用和维护</p></li><li><p>底层实现原理：</p><p> 类的底层实际是通过原型继承机制实现的,所有实例共享一个原型对象上的方法</p></li><li><p>使用：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ol><li><p>作用：</p><p> 通过export和import将代码分为多个文件,方便管理与维护</p></li><li><p>使用场景：</p><p> 任何规模应用都可以受益模块化,特别是对团队开发很有帮助</p></li><li><p>底层实现原理：</p><p> 模块化依赖于静态分析工具,编译时解析所有导入导出关系,生成并优化代码</p></li><li><p>使用：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ol><li><p>作用：</p><p> 更好的处理异步操作,避免回调地狱,更优雅的错误处理</p></li><li><p>使用场景：</p><p> 几乎所有涉及网络请求,以及文件读写等异步操作的地方都适用</p></li><li><p>底层实现原理：</p><p> Promise是一种状态机,它有待定,成功,失败三种状态,直到完成之后才触发相应的处理程序</p></li><li><p>使用：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(url)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error));<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的防抖与节流</title>
      <link href="/2025/02/25/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>/2025/02/25/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ol><li>防抖简单介绍</li></ol><blockquote><p>什么是防抖?防止事件的频繁触发。当我们给一个事件设定了防抖函数后,那么在触发事件的一定时间间隔内,如果事件再次触发,那么之前的设定的延迟执行将会被取消,重新开始计算间隔时间,只有在设定的时间间隔内没有触发事件,才会执行事件回调函数。</p></blockquote><ol><li>防抖原理</li></ol><blockquote><p>防抖的核心其实是借助javascript中的定时器setTimeout来实现的。当一个事件触发,我们先设置一个定时器,让函数延迟在一定时间内执行。如果在设定时间内,时间再次被触发,那么我们之前设定的定时器就会清除,重新开启定时器计时。只有在计时时间内时间没有被触发才会调用回调函数。</p></blockquote><ol><li><p>最简单防抖代码</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br><span class="hljs-keyword">let</span> timer;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span>;<br>    <span class="hljs-comment">// 清除之前的定时器</span><br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    <span class="hljs-comment">// 设置新的定时器</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 调用原始函数，并传递正确的上下文和参数</span><br>        func.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, delay);<br>&#125;;<br>&#125;   <br><br></code></pre></td></tr></table></figure></li></ol><blockquote><p>上方是一个最简单的防抖函数,他需要两个参数,需要添加防抖的函数,以及延迟的时间delay。函数内部首先通过clearTimeout(timer)清除之前可能存在的定时器,然后开启一个计时器,并且传入延迟时间,当延迟时间结束以后才会执行真正的事件回调函数。</p></blockquote><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><ol><li>节流简单介绍</li></ol><p>节流也是控制事件的触发频率,只不过节流是控制事件在一定时间内只能触发一次,当触发一个事件后,一定事件内事件将无法被触发。</p><ol><li>节流原理</li></ol><p><strong>实现节流的方式有两种:时间戳与定时器</strong></p><p>时间戳:时间戳的原理是在事件触发时记录当前时间戳,与上次执行函数的时间戳进行比较,如果大于预定值,就执行函数并且更新时间戳,否则就不执行函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>    <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (now - previous &gt; delay) &#123;<br>            func.<span class="hljs-title function_">apply</span>(context, args);<br>            previous = now;<br>        &#125;<br>    &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>定时器:定时器原理就是判断是否存在一个定时器,如果存在说明上一次执行还没有走完,如果不存在说明上一次执行已经完毕,此时我们设置一个定时器在延迟结束后执行函数,并清空定时器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (!timer) &#123;<br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                func.<span class="hljs-title function_">apply</span>(context, args);<br>                timer = <span class="hljs-literal">null</span>;<br>            &#125;, delay);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>搜索框联想</li></ol><blockquote><p>当我们用搜索框进行搜索时,每输入一个字符就会触发一次搜索联想请求，这将导致大量的网络请求瞬间发送到服务器,这会给服务器带来巨大压力,造成延迟,使用防抖就可以有效解决这一问题。</p></blockquote><ol><li>窗口大小调整</li></ol><blockquote><p>在窗口大小调整过程中，会频繁触发resize事件，如果在这个事件处理函数中进行复杂的页面布局调整或重新计算元素位置等操作，不进行任何优化的话，会导致浏览器性能急剧下降，出现页面卡顿、闪烁等问题。在这种情况下，我们可以根据具体需求选择使用节流或防抖技术。如果希望在用户停止调整窗口大小后，一次性进行精确的布局调整，那么防抖技术是一个不错的选择</p></blockquote><ol><li>滚动加载</li></ol><blockquote><p>许多网站和应用中，为了提高用户体验，采用了滚动加载的方式来展示大量的数据，如社交媒体平台的动态列表、新闻资讯平台的文章列表等 。当用户滚动页面时，触发scroll事件，判断是否滚动到页面底部，如果是，则向服务器发送请求，加载更多的数据并追加到页面上。节流可以大大改善用户体验</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web移动端适配方案</title>
      <link href="/2025/02/23/Web/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/"/>
      <url>/2025/02/23/Web/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ol><li>布局更多的使用flex,尺寸使用rem,vw,vh为单位。</li><li>如果是根据不同屏幕需要有不同的布局,一般通过检测屏幕尺寸换不同的站点或者媒体查询使用两套css</li></ol><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><h3 id="rem单位简单介绍"><a href="#rem单位简单介绍" class="headerlink" title="rem单位简单介绍"></a>rem单位简单介绍</h3><blockquote><p>rem以html字体大小为1rem的大小,比如说html字体大小为16px,则1rem就等于16px。rem之所以可以自适应,其实是通过js去重新设置html的字体大小</p><p>计算方式:html字体大小 = (js获取到的当前设备宽度/设计图宽度) * 设计图宽度下的rem大小</p></blockquote><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p><strong>通过媒体查询来设置不同屏幕的html的fontsize大小</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">320</span>) &#123;<br>    <span class="hljs-selector-tag">html</span>&#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">360</span>) &#123;<br>    <span class="hljs-selector-tag">html</span>&#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">480</span>) &#123;<br>    <span class="hljs-selector-tag">html</span>&#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">22px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">560</span>) &#123;<br>    <span class="hljs-selector-tag">html</span>&#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">26px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">640</span>) &#123;<br>    <span class="hljs-selector-tag">html</span>&#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">720</span>) &#123;<br>    <span class="hljs-selector-tag">html</span>&#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">34px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缺点：</strong></p><pre><code class="hljs">- 需要针对不同尺寸编写大量的媒体查询- 如果动态改变尺寸,不会实时的进行更新</code></pre><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p><strong>用js动态获取设备宽度</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.设备宽度(包含滚动条)</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">WinWidth</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">availWidth</span><br><span class="hljs-comment">// 2. 设备宽度(不包含滚动条)</span><br><span class="hljs-comment">// 移动端一般会给最外边的盒子设置最大宽度为750px,所以这边我们也需要设置以下,取两个变量中的较小值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">DocWidth</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>,<span class="hljs-number">750</span>)<br><br><span class="hljs-keyword">const</span> fontsize = (<span class="hljs-title class_">DocWidth</span>/<span class="hljs-number">750</span>)*<span class="hljs-number">16</span><br><span class="hljs-comment">// 设置html大小</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = fontsize+<span class="hljs-string">&quot;px&quot;</span><br></code></pre></td></tr></table></figure><h3 id="vh-vw单位简单介绍"><a href="#vh-vw单位简单介绍" class="headerlink" title="vh/vw单位简单介绍"></a>vh/vw单位简单介绍</h3><blockquote><p>1vw = 1%视口宽度,1vh = 1%视口高度。假设屏幕高宽是750*1200,那么1vh就是7.5px,1vw就是12px。使用vw做单位无需做计算,因为vw会自动根据屏幕宽度变化,vh一般用来做全屏设计。</p></blockquote><h2 id="方案二【仅仅是一些布局的不同】"><a href="#方案二【仅仅是一些布局的不同】" class="headerlink" title="方案二【仅仅是一些布局的不同】"></a>方案二【仅仅是一些布局的不同】</h2><p><strong>通过媒体查询,检测屏幕大小,然后使用两套不同的css</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 小于960px移动端 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen and (min-width:1px) and (max-width:959px)&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./css/iphone.css&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 大于960px,pc端 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen and (min-width:960px)&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./css/pc.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="方案三【变动太大】"><a href="#方案三【变动太大】" class="headerlink" title="方案三【变动太大】"></a>方案三【变动太大】</h2><blockquote><p>当用户进入网站时,先统一进入一个站点,然后通过js检测屏幕的宽度,是否大于一个960px【因为PC端与移动端的区分点一般就是960px】,比如说如果大于960px就让用户跳转pc端站点,小于960就跳转到移动端站点</p></blockquote><h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><ol><li>关于边距的处理:<ul><li>靠左靠右这种的一般使用flex布局</li><li>顶开小部分距离使用rem,vw</li></ul></li><li>图片一般都是设置宽度不设置高度,防止图片变形,但是如果屏幕跨度过大,可能导致图片大的很夸张,这时可以考虑设置最大宽度,然后居中,避免拉长</li><li>在一些大屏可视化项目里,界面必须是满屏幕的,不能溢出不能短,但这时通过f11切换全屏,rem,vw不会变化,所以这种项目有的高度可以考虑用vh来做</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的本地存储</title>
      <link href="/2025/02/16/JavaScript/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
      <url>/2025/02/16/JavaScript/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器的本地存储"><a href="#浏览器的本地存储" class="headerlink" title="浏览器的本地存储"></a>浏览器的本地存储</h2><blockquote><p>在浏览网站时,并不是所有数据都是存储在数据库内的,有些数据也会被浏览器存储在我们的本地,这就是浏览器的本地存储</p></blockquote><hr><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><blockquote><p>LocalStorage是Html5的新特性。有些时候我们本地存储时,需要存储的信息较大,Cookie无法满足我们的需求,这时候就可以使用LocalStorage进行本地存储</p></blockquote><ol><li>LocalStorage的优点<ol><li>LocalStorage的存储大小一把为5MB,可以存储更多的信息</li><li>LocalStorage是持久存储,并不会随着页面的关闭就消失,除非主动清理,不然会一直存在</li><li>仅存储在本地,不像Cookie那样每次HTTP请求都会被携</li></ol></li><li><p>LocalStorage的缺点</p><ol><li>存在浏览器兼容问题</li><li>如果浏览器设置为隐私模式,那我们将无法读取LocalStorage</li><li>LocalStorage受到同源策略的限制,即端口,协议,主机地址有任何不相同,都不会访问</li></ol></li><li><p>常用API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存数据到LocalStorage</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>)<br><br><span class="hljs-comment">// 从LocalStorage获取数据</span><br><span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;key&quot;</span>)<br><br><span class="hljs-comment">// 从LocalStorage删除数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;key&quot;</span>)<br><br><span class="hljs-comment">// 从LocalStorage清空所有数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>()<br><br><span class="hljs-comment">// 获取某个索引的key</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">key</span>(index)<br></code></pre></td></tr></table></figure></li><li><p>注意：</p><ul><li>存储到LocalStorage的数据key,value都必须是字符串形式,如果value不是字符串类型,那么存储到本地时会自动调用toString()方法转换为字符串类型。如果要将对象类型存储到本地,需要先调用<code>JSON.stringify()</code>方法将对象转换为字符串,读取时在调用<code>JSON.parse()</code>方法将字符串转换为对象类型</li></ul></li><li><p>使用场景</p><ul><li>有些网站有默认的换肤功能,这时可以将换肤的信息存储在本地,当需要换肤的时候,直接操作LocalStorage即可</li><li>在网站中用户浏览信息也会存储在LocalStorage中,还有网站的不常变动的个人信息也可以存储在本地的localStorage中</li></ul></li></ol><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><blockquote><p>SessionStorage和LocalStorage都是在Html5提出的储存方案,SessionStorage主要用于临时保存同意窗口的数据,刷新页面时不会删除,但是关闭窗口之后将会删除这些数据</p></blockquote><ol><li><p>SessionStorage和localStorage的对比:</p><ul><li>两者都是在本地进行数据存储</li><li>SessionStorage也有同源策略的限制,但SessionStorage更为严格,SessionStorage只有在同一浏览器的同一窗口下才能共享</li><li>两者都无法被爬虫爬取</li></ul></li><li><p>SessionStorage常用API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>)<br><br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;key&quot;</span>)<br><br><span class="hljs-comment">// 删除数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;key&quot;</span>)<br><br><span class="hljs-comment">// 清空数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">clear</span>()<br><br><span class="hljs-comment">// 获取某个key的索引</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">key</span>(index)<br></code></pre></td></tr></table></figure></li><li><p>使用场景</p></li></ol><p>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
