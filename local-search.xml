<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于Java中Stream流</title>
    <link href="/2025/05/11/Java/007JavaStream%E6%B5%81/"/>
    <url>/2025/05/11/Java/007JavaStream%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="note note-blue fas fa-bullhorn modern">            <p>本文档编写参考如下教程</p>          </div><ul><li>黑马程序员教程：<a href="https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click">黑马程序员Java零基础视频教程_上部(Java入门，含斯坦福大学练习题+力扣算法题</a></li></ul><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>Stream流使用步骤:</p><pre><code class="hljs">1. </code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java(六)字符串与集合</title>
    <link href="/2025/05/11/Java/006Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E9%9B%86%E5%90%88/"/>
    <url>/2025/05/11/Java/006Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="note note-blue fas fa-bullhorn modern">            <p>本文档编写参考如下教程</p>          </div><ul><li><p>黑马程序员教程：<a href="https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click">黑马程序员Java零基础视频教程_上部(Java入门，含斯坦福大学练习题+力扣算法题</a></p></li><li><p>菜鸟教程：<a href="https://www.runoob.com/java/java-basic-datatypes.html">Java教程</a></p></li><li><p>CSDN 天下弈星~ 帖子：<a href="https://blog.csdn.net/m0_70452407/article/details/132226860">Java | 字符串</a></p></li><li><p>CSDN 小陈学陈序员 帖子：<a href="https://blog.csdn.net/2301_76913276/article/details/135189110">java中的Collection集合（详解）</a></p></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><p>单个字符需要使用<code>char</code>类型保存,多个字符组成的文本需要保存在<code>String</code>对象中。String通常被称为字符串,一个String对象最多可以保存<code>(2^32-1)</code>个字节的内容。</p><h3 id="声明字符串"><a href="#声明字符串" class="headerlink" title="声明字符串"></a>声明字符串</h3><p>在Java中,字符串必须被包含在一对<code>&quot;&quot;</code>之内。字符串可以是系统能够显示的任何信息,甚至可以是单个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br></code></pre></td></tr></table></figure><p>声明的字符串必须被<code>初始化</code>才能使用,不然编译器会报错。</p><h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><ol><li><p>直接创建:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>通过new来创建:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 甚至可以传入一个字符数组</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>])<br></code></pre></td></tr></table></figure></li></ol><h3 id="连接多个字符串"><a href="#连接多个字符串" class="headerlink" title="连接多个字符串"></a>连接多个字符串</h3><p>连接多个字符串,只需要使用<code>+</code>连接即可。连接其他数据类型,也是通过<code>+</code>连接即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot;World&quot;</span>);<br></code></pre></td></tr></table></figure></p><h3 id="获取字符串信息"><a href="#获取字符串信息" class="headerlink" title="获取字符串信息"></a>获取字符串信息</h3><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>通过String类中的<code>length()</code>方法可以获取声明的字符串长度(包括字符串中的空格)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>str.length(); <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><p>String类提供两种查找字符串的方法:<code>indexOf()</code>和<code>lastIndexOf()</code>,这两种方法都允许在字符串中<code>查找指定条件的字符或者字符串</code>。indexOf()方法返回的是搜索的字符或者字符串<code>首次出现的索引位置</code>,lastIndexOf()方法返回的是搜索的字符或者字符串<code>最后一次出现的索引位置</code>。</p><ol><li>indexOf(String str) 与 lastIndexOf(String str)</li></ol><p>如果没有查找到指定的字符或者字符串,<code>返回的值为-1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br><br>        System.out.println(str.indexOf(<span class="hljs-string">&#x27;l&#x27;</span>)); <span class="hljs-comment">// 输出2,即第一次&#x27;l&#x27;出现的索引位置</span><br>        System.out.println(str.lastIndexOf(<span class="hljs-string">&#x27;l&#x27;</span>)); <span class="hljs-comment">// 输出9,即最后一次&#x27;l&#x27;出现的索引位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取指定索引位置的字符"><a href="#获取指定索引位置的字符" class="headerlink" title="获取指定索引位置的字符"></a>获取指定索引位置的字符</h4><p>使用<code>charAt()</code>方法可以将指定索引处的方法返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.charAt(<span class="hljs-type">int</span> index);<br></code></pre></td></tr></table></figure><h3 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h3><h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h4><p>通过String类的<code>substring()</code>方法可以对字符串进行截取。</p><ol><li>substring(int beginIndex,int endIndex)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.substring(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">// 该方法返回从指定索引位置开始,到指定索引位置结束的字符串。endIndex不传就是截取到字符串末尾</span><br></code></pre></td></tr></table></figure><h4 id="去除字符串中的空格"><a href="#去除字符串中的空格" class="headerlink" title="去除字符串中的空格"></a>去除字符串中的空格</h4><p><code>trim()</code>方法,可以去除字符串中的前后空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   Hello World   &quot;</span>;<br>str.trim(); <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><h4 id="字符或字符串的替换"><a href="#字符或字符串的替换" class="headerlink" title="字符或字符串的替换"></a>字符或字符串的替换</h4><p><code>replace()</code>方法可以实现将字符串中指定的<code>字符或者字符串</code>全部<code>替换</code>为新的字符或字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.replace(<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>); <span class="hljs-comment">// HeLLo WorLd</span><br></code></pre></td></tr></table></figure><p><strong><em>第一个参数为指定的字符或字符串,第二个参数为要替换为的目标字符串</em></strong></p><h4 id="判断字符串的开始与结尾"><a href="#判断字符串的开始与结尾" class="headerlink" title="判断字符串的开始与结尾"></a>判断字符串的开始与结尾</h4><p><code>startsWith()</code>与<code>endsWith()</code>方法分别用于表示判断字符串是否已指定的字符或者字符串开始,返回值为boolean类型。</p><ol><li>startsWith()</li></ol><p>判断字符串是否以指定字符或字符串开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.startsWith(<span class="hljs-string">&quot;H&quot;</span>)<br></code></pre></td></tr></table></figure><ol><li>endsWith()</li></ol><p>判断字符串是否以指定字符或字符串结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.endsWith(<span class="hljs-string">&quot;d&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="判断字符串是否相等"><a href="#判断字符串是否相等" class="headerlink" title="判断字符串是否相等"></a>判断字符串是否相等</h4><p>对字符串对象进行比较不能只使用简单的<code>==</code>运算符,因为比较运算符比较的是两个字符串的地址是否相同,有时候<code>即便两个字符串的内容相同字符串的地址也是不同的</code>。</p><ol><li>equals() 与 equalsIgnoreCase()</li></ol><p>如果只是判断两个字符串的内容是否相同,可以使用<code>equals()</code>方法与<code>equalsIgnoreCase()</code>方法。equals()方法比较两个字符串的内容是否相等,而equalsIgnoreCase()也可以比较内容,并且<code>是忽视大小写的</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;Hello World&quot;</span>.equals(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-string">&quot;Hello World&quot;</span>.equalsIgnoreCase(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="按字典顺序比较两个字符串"><a href="#按字典顺序比较两个字符串" class="headerlink" title="按字典顺序比较两个字符串"></a>按字典顺序比较两个字符串</h4><p><code>compareTo()</code>方法为<code>按字典顺序</code>比较两个字符串,该比较基于字符串中的各个字符的<code>Unicode</code>值,按字典顺序将对象表示的字符序列与参数字符串所表示的字符序列进行比较。如果String对象位于参数字符串之前,则结果为一个负数;如果String对象位于参数字符串之后,则结果为一个正数;如果相等,返回0,只有在equals()返回true的时候才会返回0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.compareTo(<span class="hljs-string">&quot;Hello&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="字母大小写转换"><a href="#字母大小写转换" class="headerlink" title="字母大小写转换"></a>字母大小写转换</h4><p>String类的<code>toLowerCase()方法</code>与<code>toUpperCase()方法</code>可以将字符串中的所有大写字母改为小写字母或者将所有的小写字母改为大写字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">str.toLowerCase(<span class="hljs-string">&quot;Hello World&quot;</span>); <span class="hljs-comment">// hello world</span><br>str.toUpperCase(<span class="hljs-string">&quot;Hello World&quot;</span>); <span class="hljs-comment">// HELLO WORLD</span><br></code></pre></td></tr></table></figure><h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><p>使用<code>split()</code>方法可以使字符串按指定的分割字符或字符串进行分割,并将分割后的结果存放在字符串数组中返回,<code>split()</code>方法提供两种分割形式。</p><ol><li><p>str.split(String str1)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;Hello World&quot;</span>.split(<span class="hljs-string">&quot;l&quot;</span>)<br></code></pre></td></tr></table></figure><p> 如果想定义多个分割符,可以使用符号”|”,例如”,|=”</p></li><li><p>str.split(String str1,int limit)</p></li></ol><p>根据分割字符进行分割,并且限制分割次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.split(<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>String类的format()方法用于创建<code>格式化字符串</code>,format()方法有两种重载形式。</p><ol><li>format(String format,Object… args)</li></ol><p>方法使用指定的格式化字符串和参数返回一个格式化字符串,格式化后的新字符串使用本地默认的语言环境</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.format(String format,Object... args)<br></code></pre></td></tr></table></figure><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><div class="table-container"><table><thead><tr><th>转化符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%te</td><td>一个月中的某一天(1~31)</td><td>2</td></tr><tr><td>%tb/%tB</td><td>月份简称/全称</td><td>Feb/February</td></tr><tr><td>%ta/%tA</td><td>星期简称/全称</td><td>Sun/Sunday</td></tr><tr><td>%tc</td><td>包括全部日期与时间信息</td><td>星期六 3月 29 13:44:00 CST 2025</td></tr><tr><td>%tY/ty</td><td>四位/两位年份</td><td>2025/25</td></tr><tr><td>%tj</td><td>一年中的第几天(001-366)</td><td>085</td></tr><tr><td>%tm</td><td>月份</td><td>03</td></tr><tr><td>%td</td><td>一个月中的某一天(01~31)</td><td>02</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>        System.out.println(<span class="hljs-string">&quot;今年是:&quot;</span> + String.format(<span class="hljs-string">&quot;%tY&quot;</span>, date) + <span class="hljs-string">&quot;年&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;本月是:&quot;</span> + String.format(<span class="hljs-string">&quot;%tm&quot;</span>, date) + <span class="hljs-string">&quot;月&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;今日是:&quot;</span> + String.format(<span class="hljs-string">&quot;%td&quot;</span>, date) + <span class="hljs-string">&quot;号&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><div class="table-container"><table><thead><tr><th>转化符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%tH</td><td>小时(0~23)</td><td>13</td></tr><tr><td>%tI</td><td>小时(1~12)</td><td>01</td></tr><tr><td>%tK</td><td>小时(1~12)</td><td>1</td></tr><tr><td>%tM</td><td>分钟</td><td>44</td></tr><tr><td>%tS</td><td>秒</td><td>00</td></tr><tr><td>%tL</td><td>毫秒</td><td>000</td></tr><tr><td>%tQ</td><td>纳秒</td><td>000000000</td></tr><tr><td>%tZ/tz</td><td>时区/时区缩写</td><td>+0800/CST</td></tr><tr><td>%tp</td><td>上午/下午</td><td>上午/pm</td></tr><tr><td>%ts</td><td>1970-01-01 00:00:00到现在的秒数</td><td>12064515</td></tr><tr><td>%tQ</td><td>1970-01-01 00:00:00到现在的毫秒数</td><td>12066889455</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>        System.out.print(<span class="hljs-string">&quot;现在是:&quot;</span> + String.format(<span class="hljs-string">&quot;%tH&quot;</span>, date) + <span class="hljs-string">&quot;时&quot;</span>);<br>        System.out.print(String.format(<span class="hljs-string">&quot;%tM&quot;</span>, date) + <span class="hljs-string">&quot;分&quot;</span>);<br>        System.out.print(<span class="hljs-string">&quot;&quot;</span> + String.format(<span class="hljs-string">&quot;%tS&quot;</span>, date) + <span class="hljs-string">&quot;秒&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="日期与时间常见组合"><a href="#日期与时间常见组合" class="headerlink" title="日期与时间常见组合"></a>日期与时间常见组合</h4><div class="table-container"><table><thead><tr><th>格式化字符串</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%tF</td><td>“年-月-日”(4位年份)</td><td>2025-03-02</td></tr><tr><td>%tD</td><td>“年/月/日”(两位年份)</td><td>25/03/02</td></tr><tr><td>%tc</td><td>全部日期和时间信息</td><td>星期二 三月 25 15:20:00 CTS 2025</td></tr><tr><td>%tr</td><td>“时:分:秒 PM”</td><td>03:22:06 下午</td></tr><tr><td>%tT</td><td>“时:分:秒”</td><td>03:22:06</td></tr><tr><td>%tR</td><td>“时:分”</td><td>03:22</td></tr></tbody></table></div><h4 id="字符串生成器-StringBuilder"><a href="#字符串生成器-StringBuilder" class="headerlink" title="字符串生成器 StringBuilder"></a>字符串生成器 StringBuilder</h4><p>创建成功的字符串对象,其长度都是<code>固定的</code>,内容不能被修改与编译。虽然可以使用<code>+</code>达到字符串的拼接效果,但这样会产生一个新的String实例,<code>效率低</code>。而<code>可变的字符串序列StringBuilder类</code>可以大大提高频繁增加字符串的效率。</p><p>如果在程序中<code>频繁的附加字符串</code>,建议使用StringBuilder类。新创建的StringBuilder对象容量16字符,可自行指定初始长度,如果附加的字符超出容量,StringBuilder会自行增加容量,如果要输出字符串可以使用<code>toString()</code>方法。利用StringBuilder可以动态的执行字符串的增删改查操作。</p><ol><li><p>append()方法</p><p> 用于<code>向字符串生成器中追加内容</code>。通过重载,可以实现接收任何类型的参数或另一个字符串生成器。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><br>        str.append(<span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">// 拼接字符串</span><br><br>        System.out.println(str); <span class="hljs-comment">// HelloWorld</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>insert(index,str)方法</p><p> 该方法用于向字符串指定位置<code>插入数据</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Ho&quot;</span>);<br><br>        str.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ell&quot;</span>); <span class="hljs-comment">// 在H后面插入数据</span><br><br>        System.out.println(str); <span class="hljs-comment">// Hello</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>delete(start,end)方法</p><p> <code>移除字符串中的字符</code>,从指定索引开始到指定索引结束<code>(不包括end索引的字符)</code>的字符。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hehujunxillo&quot;</span>);<br><br>        str.delete(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>); <span class="hljs-comment">// 移除字符串</span><br><br>        System.out.println(str); <span class="hljs-comment">// Hello</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合:<code>存储对象的容器</code>,<code>存储对象</code>的<code>对象</code>。在数组中也可以存储对象,而用<code>Collection集合</code>存储对象,可以使对象有更多的特点和功能。特点是:容器的工具类,定义了对多个对象进行操作的方法。</p><p><code>Collection接口</code>的子类集合有些是允许有重复元素,有些没有。JDK不提供任何实现类直接实现此接口。Collection接口有很多抽象方法,是它子接口或者实现类共性的标准。</p><ol><li>特点:<br> 代表一组<code>任意类型</code>的对象,无序,无下标。</li><li>方法:<ol><li>.add(Object obj):添加一个对象return true or false</li><li>.addAll(Collection c):将一个集合中的所有元素添加进另外一个集合return true or false</li><li>.clear():清空集合 void</li><li>.contains(Object obj):判断集合中是否包含obj对象return true or false</li><li>.equals(Object obj):比较集合是否与指定对象相等return true or false</li><li>.isEmpty():判断此集合是否为空return true or false</li><li>.remove(Object obj):移除obj对象return true or false</li><li>.size():返回集合中的元素个数return int</li><li>.toArray():将集合转换为数组return Object[]</li></ol></li></ol><h3 id="List接口集合"><a href="#List接口集合" class="headerlink" title="List接口集合"></a>List接口集合</h3><p>List接口的特点:<code>有序</code>,<code>有下标</code>,<code>元素可重复</code>。</p><ol><li><code>.add(int index,Object obj)</code>-在index的位置上插上元素,<code>无返回值</code></li><li><code>.addAll(int index,Collection c)</code>-将一个集合中的元素添加到此集合中的index位置,返回boolean</li><li><code>.get(int index)</code>-获取指定位置的元素,返回Object</li><li><code>.subList(int fromIndex,int toIndex)</code>-返回它们之间的集合元素,返回List</li></ol><h4 id="ArrayList实现类"><a href="#ArrayList实现类" class="headerlink" title="ArrayList实现类"></a>ArrayList实现类</h4><p>ArrayList实现类遵循Collection和List接口的标准,所以ArrayList实现类具备<code>有序</code>,<code>有下标</code>,<code>元素可重复</code>三种特点。<code>底层是数据结构实现,查询快,增删慢</code>。</p><p><strong><em>注:当在中间插入元素时,后面的每个元素需要往后按顺序移动。</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;E&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p><strong><em>注意其中<code>&lt;E&gt;</code>代表<code>泛型</code>。Java中,泛型通过&lt;&gt;来指定类型参数,如:ArrayList<String></em></strong></p><p>List接口的可调整数组大小实现。实现所有可选列表操作,并允许所有元素,包括null。除了实现List接口外,此类还提供一些方法来操作内部用于存储列表数据的大小。(这个类类似于Vertor,除了它是不同步的,所以在<code>线程不安全,但是运行效率快</code>)。</p><blockquote><p>ArrayList的构造方法:</p><pre><code class="hljs">1. ArrayList():构造一个初始容量为10的空列表。2. ArrayList(int initialCapacity):构造一个具有指定初始容量的空列表。3. ArrayList(Collection&lt;? extends E&gt; c):构造一个包含指定集合元素的列表,按照集合迭代器返回元素顺序。</code></pre></blockquote><p><strong><em>注意:ArrayList实现类底层是一个数组;数组结构实现,查询快,增删慢。JDK6初始容量为10,JDK7初始容量改为0。？一开始初始化容量为10的话,不使用那么容器就会造成资源浪费,初始化改为0,只需添加一个元素会自动+1。</em></strong></p><blockquote><p>集合中只能包含引用数据类型,无法包含基础数据类型,想要集合中写入基础数据类型,需要通过<code>包装类</code>(用于将基本数据类型封装成数据类)。除了以下两个,剩下的只需将首字母大写就好了</p></blockquote><pre><code class="hljs">1. Integet -- 用于包装整形(int)2. Character -- 用于包装字符类型(char)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;<span class="hljs-type">int</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 报错,因为集合无法包含基础数据类型,需要采取包装类</span><br><br>ArrayList&lt;Integer&gt; List <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></code></pre><h4 id="Vector实现类"><a href="#Vector实现类" class="headerlink" title="Vector实现类"></a>Vector实现类</h4><p>Vector实现类与ArrayList实现类一样,都是<code>有序,有下标,元素可重复</code>,底层都是<code>数组结构实现,查询快,增删慢</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><blockquote><p>Vector与ArrayList类的区别在于:Vector的线程是安全的,但运行速率慢,而ArrayList类是不安全的,但运行速率快。如果不考虑线程安全问题,可以使用ArrayList代替Vector。</p></blockquote><h4 id="LinkedList实现类"><a href="#LinkedList实现类" class="headerlink" title="LinkedList实现类"></a>LinkedList实现类</h4><p>LinkedList实现类同样具备<code>有序,有下标,元素可重复</code>的特点。底层是<code>链表结构实现,查询慢,增删快。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>所有操作的执行都符合双向链表的预期。索引都列表中的操作将从开头或结尾遍历列表,以更接近指定索引的为准。</p><p><strong><em>在中间插入元素时,无需移动元素,直接开辟空间让前面的元素指向该空间</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java(五)封装&amp;继承&amp;多态</title>
    <link href="/2025/05/11/Java/005Java%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    <url>/2025/05/11/Java/005Java%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="note note-blue fas fa-bullhorn modern">            <p>本文档编写参考如下教程</p>          </div><ul><li><p>黑马程序员教程：<a href="https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click">黑马程序员Java零基础视频教程_上部(Java入门，含斯坦福大学练习题+力扣算法题</a></p></li><li><p>菜鸟教程：<a href="https://www.runoob.com/java/java-basic-datatypes.html">Java教程</a></p></li><li><p>CSDN 旺旺碎冰冰、 帖子：<a href="https://blog.csdn.net/m0_75178616/article/details/142004276">Java之封装</a></p></li><li><p>CSDN 权^ 帖子：<a href="https://blog.csdn.net/2302_81090306/article/details/142995802">java—继承（详解）</a></p></li><li><p>CSDN Lizhihao＿  帖子：<a href="https://blog.csdn.net/Lizhihao_/article/details/140948653">JAVA-继承(CSDN最详细的)</a></p></li></ul><hr><p>在所有面向对象编程中,基本都有三大特性:<code>封装</code>,<code>继承</code>,<code>多态</code>。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><code>封装</code>就是将<code>对象的状态(数据)和行为(方法)打包在一起</code>,隐藏对象内部实现细节,只提供<code>公开的接口(getter,setter方法)</code>来与<code>对象进行交互</code>。</p><h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>在Java内,需要通过类的访问权限来实现封装,<code>访问权限修饰符</code>可以控制类,变量,方法或其他引用对象的访问级别。Java中有四种访问权限修饰符。</p><ol><li><code>private</code>:私有访问级别,只有同一个包中,同一个类才可以访问。</li><li><code>default</code>:默认级别,同一个包中,不同类也可以访问。</li><li><code>protected</code>:保护访问级别,不在同一个包中,只要是子类也可以访问。</li><li><code>public</code>:公共访问级别,任何地方都可以访问。</li></ol><p>一般情况下,成员变量定义<code>private</code>,成员方法定义<code>public</code>。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><code>包</code>其实就是一个文件夹,为了更好管理。将类划分,将多个类收集成一组就是一个包。在Java中,包是一种用来<code>组织与管理类和接口</code>的机制。可以为开发者提供一种<code>逻辑分组</code>的方式,使得代码更加模块化,结构化和易于管理。</p><ol><li><p>导包:</p><p> 在Java内有许多内置类,如:<code>Date,Scanner</code>,需要使用<code>java.util.Date;</code>去导包。其实<code>java.util</code>就是包名,<code>Date</code>代表包中的类。</p></li><li><p>自定义包:</p><ol><li>包名与代码路径的匹配。例如创建一个com.school.student的包,那么它对应的路径就是com/school/student。</li><li>包名尽量指定为唯一的名字(企业通常将自己企业的域名颠倒过来命名包名)。</li><li>当创建一个Java文件时,最上面的package语句就是指定该文件放在了那个包中。</li><li><p>如果一个类没有package语句,那么该类被放到默认包中。</p><p>创建自定义包:右键<code>src</code>目录,选择<code>New Java Package</code>选项,输入包名即可</p><p><img src="https://pic1.imgdb.cn/item/67e379eb0ba3d5a1d7e37115.png" alt=""></p><p>创建好后就能看见创建的包目录了。在包目录内创建一个java文件,文件的顶部就会显示,该文件属于哪个包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件属于哪个包</span><br><span class="hljs-keyword">package</span> com.school.gzuhoaix;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="static-修饰的成员变量"><a href="#static-修饰的成员变量" class="headerlink" title="static 修饰的成员变量"></a>static 修饰的成员变量</h4><p>static修饰的成员变量,称为<code>静态成员变量</code>。静态成员变量不属于某个具体的对象,而是<code>所有的对象共享的</code>。</p><ol><li><p>特征:</p><ol><li>又称<code>静态属性</code>,不属于某个具体的对象,是类的属性,所有对象共享。</li><li>静态成员变量可以<code>通过类名直接访问</code>,也可以通过对象访问(为了区分静态成员变量,一般不会使用对象访问,更推荐使用<code>类名访问</code>)</li><li>静态成员变量<code>存储在堆的静态区</code>中。</li><li>生命周期随着类的加载而被创建,随着类的卸载而被销毁。与对象无关。</li></ol></li><li><p>示例:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">static</span> String occupation;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 通过类访问静态成员变量</span><br>        System.out.println(Person.occupation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>静态成员变量的初始化:</p><p> <code>静态成员变量一般不会在构造方法中初始化</code>。静态成员变量的初始化分为两种:<code>就地初始化</code>和<code>静态代码块初始化</code>。</p><ol><li>就地初始化:直接在定义静态成员变量时初始化赋值。</li><li><code>静态代码块初始化</code>:理解了代码块就知道了。</li></ol></li></ol><h4 id="static-修饰成员方法"><a href="#static-修饰成员方法" class="headerlink" title="static 修饰成员方法"></a>static 修饰成员方法</h4><p>在封装中,类的成员变量一般都设置为<code>private</code>,而成员方法设置为<code>public</code>,当成员变量被设置为private后,在其他类中,就不能直接访问,而是需要借助成员方法来进行访问。<br>与静态成员变量一样,在Java中static修饰的方法被称为静态成员方法,是类的方法,而不是某个特有对象的方法。<code>静态成员变量一般通过静态成员方法来访问</code>。<code>通过类名调用</code>,不推荐使用对象调用。</p><ol><li><p>注意:</p><ol><li>静态方法不需要对象调用,所以<code>不能传递this</code>。</li><li><code>静态方法</code>中不能调用任何<code>非静态成员变量</code>。</li><li>静态方法中不能调用任何<code>非静态方法</code>,但是可以在任何非静态方法中调用静态方法。</li></ol></li><li><p>示例:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">occupation</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;网站开发&quot;</span>;<br><br>    <span class="hljs-comment">// 静态成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getOccupation</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> occupation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 通过类访问静态成员方法获取静态成员变量</span><br>        System.out.println(Person.getOccupation());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h4><p>普通代码块就是定义在方法中的,拿<code>&#123;&#125;</code>包裹着的一段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;World!!!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例化代码块"><a href="#实例化代码块" class="headerlink" title="实例化代码块"></a>实例化代码块</h4><p>又叫构造代码块,一般用于<code>初始化实例成员变量</code>的时候。<code>实例化代码块的执行顺序优先于构造函数</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">occupation</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;网站开发&quot;</span>;<br>    String name;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;实例化代码块&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p><code>静态代码块</code>就是static定义的代码块,一般用于<code>初始化静态成员变量</code>。静态代码块的执行顺序优先于构造代码块。(静态代码块 -&gt; 构造代码块 -&gt; 构造函数)。静态代码块只会执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String occupation;<br>    String name;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>        <span class="hljs-comment">// 初始化静态成员变量</span><br>        occupation = <span class="hljs-string">&quot;网站开发&quot;</span>;<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;实例化代码块&quot;</span>);<br>        <span class="hljs-comment">// 初始化成员变量</span><br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ol><li>静态代码块只会执行一次。</li><li>如果一个类中定义了多个静态代码块,编译时,编译器会按照定义的先后顺序执行。</li><li>静态成员变量是类的属性,所以是在JVM加载类时开辟空间初始化的。</li><li>实例代码块只有在创建对象时才会执行,构造方法也是。</li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>程序世界中使用类对现实世界的实体来进行描述,而使用类实例化出来的对象就可以表示一个又一个的实体。但现实世界错综复杂,不同的实物之间又可能会存在一些联系。比如:手机,如今国内手机行业不像国外人均苹果,三星,国内有小米,华为,VIVO,OPPO,苹果…品牌。这些品牌它们都属于手机类,但它们又都有属于自己的特点,比如:苹果比较流畅,小米性价比高,vivo听说拍照比较不错之类的。这时候如果还与之前一样创建一个类存放这些手机,那这个类未免有些杂乱了。可如果定义三个类分别表示这些手机,那就会发现这三个类中有很多重复的代码。这时就可以使用<code>继承</code>,也就是将三个类中的<code>重复代码抽离出来</code>,放在一个父类,然后让这三个类继承自这个父类。</p><p>在Java中,如果要表示类之间的继承关系,需要借助<code>extends</code>关键字。继承的好处,就是可以<code>对代码进行复用</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>    <span class="hljs-comment">// 所有手机都有的成员变量</span><br>    <span class="hljs-type">int</span> price;<br>    String phoneName;<br>    String brand;<br><br>    <span class="hljs-comment">// 手机都有的成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 小米手机继承手机类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoMi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-comment">// 小米手机独有的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cheap</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;只要1999&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apple</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机很流畅&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vivo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">vivo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机拍照不错&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 实例化小米手机</span><br>        <span class="hljs-type">XiaoMi</span> <span class="hljs-variable">xiaomi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaoMi</span>();<br>        <span class="hljs-comment">// 声明手机类共有的成员变量</span><br>        xiaomi.price = <span class="hljs-number">1999</span>;<br>        xiaomi.phoneName = <span class="hljs-string">&quot;小米5s&quot;</span>;<br>        xiaomi.brand = <span class="hljs-string">&quot;小米手机&quot;</span>;<br><br>        <span class="hljs-comment">// 使用所有手机类共有的成员方法</span><br>        xiaomi.call();<br>        <span class="hljs-comment">// 使用小米手机类独有的成员方法</span><br>        xiaomi.cheap();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>注意:<ol><li>子类会将父类父类中的<code>成员变量</code>或者<code>成员方法</code>继承到子类中。</li><li>子类继承父类之后,必须要新添加自己特有的成员,体现出与父类的不同,否则就没有必要继承了。</li></ol></li></ol><h3 id="父类成员变量与成员方法的访问"><a href="#父类成员变量与成员方法的访问" class="headerlink" title="父类成员变量与成员方法的访问"></a>父类成员变量与成员方法的访问</h3><ol><li>子类中存在而父类中不存在的成员变量,直接访问即可。</li><li><p>子类中存在父类中也存在的同名成员变量,此时直接访问会优先访问子类中的成员变量。</p></li><li><p><code>子类方法中</code>或者<code>通过子类对象访问成员</code>时:</p><ol><li>如果访问的成员变量子类中有时,优先访问子类的成员变量。</li><li>如果访问的成员变量子类中没有,则访问父类继承的,如果依然没有就会有语法错误。</li><li>访问的成员变量与父类的成员变量同名,<code>优先访问自己的</code>。</li></ol></li><li><p>访问成员方法时:</p><ol><li>通过子类对象访问父类与子类中不同名的方法时,依然是优先访问子类,其次才是父类。</li><li>通过派生类对象访问父类与子类同名方法时,如果父类与子类同名方法参数列表不同(重载),根据传递的参数选择合适的访问即可。</li></ol></li></ol><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>有时子类与父类中,可能存在相同名称的成员,如果要在子类方法中访问父类中的<code>同名成员变量</code>,一般情况是访问不到的。Java提供了<code>super</code>关键字,该关键字的主要作用就是在子类中访问父类的成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSpedd</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 此时获取到的speed属性,就是Car类中的speed属性</span><br>        System.out.println(<span class="hljs-built_in">super</span>.speed); <span class="hljs-comment">// 2000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在子类中获取父类的同名成员变量只需要借助<code>super</code>即可。只能在<code>非静态方法与非静态代码块</code>中使用。</p><h3 id="子类构造方法"><a href="#子类构造方法" class="headerlink" title="子类构造方法"></a>子类构造方法</h3><p>子类对象构造时,需要<code>先执行父类的构造方法</code>,然后在执行子类的构造方法。原因是子类对象中的成员是由两部分组成的,父类继承的以及子类新增的。所以构造子类时,需要先调用父类的构造函数,将从<code>父类继承下来的成员</code>构造完整,然后再调用子类自己的构造方法,将自己<code>新增的成员完成初始化</code>。<br>子类构造方法中<code>super()</code>可以调用父类构造方法,而且<code>super()</code>语句必须放在<code>第一行</code>(有点类似于this())。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> speed;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> speed)</span>&#123;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    String color;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Train</span><span class="hljs-params">(<span class="hljs-type">int</span> speed,String color)</span>&#123;<br>        <span class="hljs-built_in">super</span>(speed);<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Train</span> <span class="hljs-variable">tr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;red&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>若父类显示定义无参数或者默认的构造函数,则在子类构造函数的第一行默认有隐藏的super()调用。</li><li>如果父类构造函数带参,此时需要用户为子类手动定义构造方法,并在子类构造方法中选择合适的父类构造方法调用。</li><li>在子类构造方法中super(…)调用父类构造时,必须是子类构造函数中的第一条语句。</li><li>super(…)只能在子类构造方法中出现一次,并且不能和<code>this</code>同时出现。</li></ol><h3 id="super与this的区别"><a href="#super与this的区别" class="headerlink" title="super与this的区别"></a>super与this的区别</h3><p>super与this都可以在成员方法中用来访问:成员变量和调用其他的成员函数,都可以作为构造函数的第一条语句。</p><ol><li><p>相同点:</p><ol><li>都是Java中的关键字。</li><li>只能在类的<code>非静态方法</code>中使用,用来访问<code>非静态成员方法与字段</code>。</li><li>在构造函数中调用时,必须作为构造函数的第一条语句,<code>不能同时出现</code>。</li></ol></li><li><p>不同点:</p><ol><li>this是当前对象的引用,即调用当前实例方法的对象。super相当于子类中继承自父类的部分成员的引用。</li><li>在非静态的成员方法中,this用来访问<code>本类的方法与属性</code>,super用来访问<code>父类继承下来的方法与属性</code>。</li><li>在构造方法中:this(…)<code>用于调用本类构造函数</code>。super(…)用于调用父类构造函数,两者调用不能同时出现。</li><li>构造方法中一定会存在super(…)的调用(有父类的方法),用户不写也会默认增加,但this(…)用户不写就不会增加。</li></ol></li></ol><h3 id="初始化语句执行顺序"><a href="#初始化语句执行顺序" class="headerlink" title="初始化语句执行顺序"></a>初始化语句执行顺序</h3><ol><li>最先执行应该是<code>父类的静态代码块</code>,紧接着是<code>子类的静态代码块</code>。</li><li>父类实例化代码块与父类构造函数开始执行。</li><li>子类实例化代码块与子类构造函数执行。</li><li>第二次实例化子类对象时,父类与子类的静态代码块都不会在执行。</li></ol><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><ol><li>单继承:也就是一个子类继承自一个父类。</li><li>多继承:一个子类继承自一个父类,而子类又被一个更小的类继承。</li><li>不同类继承同一个类:一个父类被多个子类同时继承。</li></ol><blockquote><p>注意:Java不支持一个子类同时继承自两个或两个以上的父类。在真正的项目开发中,往往业务会很复杂,类也会很多,类与类之间的关系也很复杂,一般不希望出现三层以上的继承关系,如果继承层太多,就需要考虑对面代码进行重构,想从语法上限制继承,可以使用”final”关键字。</p></blockquote><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ol><li><p>final 修饰变量:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p> final修饰的变量或字段,表示<code>常量</code>(即不能被修改)。final修饰的<code>常量最好使用全大写字母</code>。</p></li><li><p>final修饰类:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p> final 修饰的类<code>表示不能被继承</code>。也叫<code>封装类</code>。</p></li><li><p>final 修饰方法:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p> final 修饰的方法表示该方法<code>不能被重写</code>。</p></li></ol><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><p>与继承类似,组合也是一种表示类之间关系的方式,也能够达到代码重用的效果。组合并没有涉及到特殊的语法,<code>仅仅是将一个类的实例对象作为另一个类的成员变量</code>。<br>继承表示对象之间是…的关系,如:男人是人,女人是人。组合表示对象之间有…的关系,如:汽车有发动机,有轮胎。学校内有多个老师与同学,只有一位校长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span> &#123;<br>    <span class="hljs-comment">// 将别的类实例化对象作为此类成员变量</span><br>    <span class="hljs-keyword">public</span> Student[] students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 多个学生</span><br>    <span class="hljs-keyword">public</span> Teacher[] teachers; <span class="hljs-comment">// 多个老师</span><br>    <span class="hljs-keyword">public</span> President president; <span class="hljs-comment">// 一位校长</span><br>&#125;<br><br><span class="hljs-comment">// 学生</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 老师</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 校长</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">President</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是同一个行为具有<code>不同的表现形式</code>或形态的能力,同一个方法可以根据<code>发送对象</code>的不同采取不同的行为方式。总的来说多态就是事物的多种形态,一个对象在不同条件下所表现的不同形式。</p><ol><li><p>如何实现多态:</p><ol><li>在多态中必须存在<code>继承或实现关系</code>的子类和父类。</li><li>子类对父类的某些方法进行重新定义。</li><li>通过<code>父类的引用</code>调用重写的方法。</li></ol></li><li><p>格式:</p><ul><li>父类类名 变量名 = new 子类类名();</li><li>通过<code>变量名.方法名()</code>,这种格式来调用在<code>子类中重写</code>的方法。</li></ul></li></ol><h3 id="多态中的成员变量"><a href="#多态中的成员变量" class="headerlink" title="多态中的成员变量"></a>多态中的成员变量</h3><p><code>编译运行看左边,即看的是父类中的变量。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>();<br><br>        System.out.println(car.speed); <span class="hljs-comment">// 此时打印的是父类中的变量,也就是1000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>父类声明子类实例这种的<code>成员变量</code>,都是编译运行看左边,也就是获取到的是父类中的成员变脸。</p><h3 id="多态中的成员方法"><a href="#多态中的成员方法" class="headerlink" title="多态中的成员方法"></a>多态中的成员方法</h3><p><code>编译看左边,运行看右边</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Car is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Train is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>();<br><br>        System.out.println(car.speed); <span class="hljs-comment">// 此时打印的是父类中的变量,也就是1000</span><br>        car.run(); <span class="hljs-comment">// 此时输出&quot;Train is running&quot;,即调用的是子类中重写的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当子类的方法与父类的方法有<code>相同的名称</code>,<code>返回类型</code>,<code>参数列表</code>此时间就会发生<code>重写</code>现象,这是会<code>调用子类的成员方法</code>来取代父类的实现。这里只是针对子类与父类方法名相同的成员方法才会发生的情况。</p><h3 id="重写的注意事项"><a href="#重写的注意事项" class="headerlink" title="重写的注意事项"></a>重写的注意事项</h3><ol><li><code>方法名</code>必须相同</li><li><code>参数列表</code>必须相同(类型,个数,顺序)</li><li><code>返回值</code>必须相同,如果想要返回值类型不同,则返回关系类型必须为父子类关系。</li><li>父类<code>被private修饰</code>的方法,不能进行重写。</li><li>父类<code>被static修饰</code>的方法,不能进行重写。</li><li>父类<code>被final修饰</code>的方法,不能进行重写,此时这个方法被叫做<code>密封方法</code>。</li><li>构造方法不能重写。</li><li>访问修饰限定符private&lt;默认权限(即什么都不写)&lt; protected &lt; public子类的访问修饰限定符权限一定要大于等于父类,才能发生重写现象。</li></ol><p><strong><em>重写这个运行过程一般也被称为<code>动态绑定</code></em></strong></p><h3 id="多态特点"><a href="#多态特点" class="headerlink" title="多态特点"></a>多态特点</h3><ol><li>当子类与父类存在相同的成员变量时,编译器会访问<code>父类的成员变量</code></li><li>当子类与父类存在相同的成员方法时,此时会发生<code>重写</code>现象,编译器会访问子类中的成员方法</li><li>当子类中有方法,而父类没有时,则不能访问子类中独有的方法(也不是不行,需要一些手段)</li><li>子类与父类存在同名的<code>静态成员函数</code>时,访问的是<code>父类的成员函数</code></li><li>以上这些特点均是在<code>多态的情况下发生</code>的</li></ol><h2 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h2><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p><code>向上转型</code>是Java中常用的类型转换方式之一,也称为<code>自动类型转换</code>。这种类型转换发生在继承关系中,父子类之间,通常是将<code>子类对象转换为父类对象</code>。</p><p><strong><em>向上转型的三种方法</em></strong></p><ol><li>直接赋值</li><li>方法传递的参数</li><li>返回值</li></ol><h4 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Train</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">super</span>(speed, color);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>); <span class="hljs-comment">// 直接赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Car is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Train</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">super</span>(speed, color);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Train is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>); <span class="hljs-comment">// 直接赋值</span><br>        fun(car); <span class="hljs-comment">// 以car作为参数传值</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(Car car)</span>&#123;<br>        car.run(); <span class="hljs-comment">// 输出&quot;Train is running&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> fun(); <span class="hljs-comment">// 返回值</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;red&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上就是向上转型的是那种方式,可以看出向上转型无法调用子类特有的方法,只能调用父类自己的方法,除非发生方法重写,否则无法调用。</p></blockquote><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>将一个子类对象向上转型可以当做父类对象使用,如果需要<code>调用子类特有的方法</code>,则只需将<code>父类对象在转换为子类对象</code>即可,这就是<code>向下转型</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>);<br><br>        <span class="hljs-type">Train</span> <span class="hljs-variable">train</span> <span class="hljs-operator">=</span> (Train)car; <span class="hljs-comment">// 向下转型,将父类对象强制转换为子类</span><br><br>        train.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>向下转型之后,不仅可以调用父类的方法,还可以<code>调用子类特有的方法</code>。</p><h4 id="向下转型缺点"><a href="#向下转型缺点" class="headerlink" title="向下转型缺点"></a>向下转型缺点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">speed</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Car is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Train</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, String color)</span>&#123;<br>        <span class="hljs-built_in">super</span>(speed, color);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Train is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 新增一个子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Bus is running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>);<br><br>        <span class="hljs-type">Bus</span> <span class="hljs-variable">bus</span> <span class="hljs-operator">=</span> (Bus)car; <span class="hljs-comment">// 向下转型,将父类对象强制转换为子类</span><br><br>        bus.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时代码虽然没有语法错误,但是运行之后就会报异常,即类型转换异常。</p><blockquote><p>Exception in thread “main” java.lang.ClassCastException: class Train cannot be cast to class Bus (Train and Bus are in unnamed module of loader ‘app’) at App.main(App.java:5)</p></blockquote><ol><li>在启动项中,向上转型的过程,car这个对象是由Train类所构造出来的</li><li>而在向下转型的过程中,把car这个对象转换为了Bus类对象</li><li>虽然Train和Bus都是Car的子类</li><li>但将Train对象转换为Bus对象还是不科学</li></ol><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>想要避免向下转型遇到的类型转换异常,可以使用<code>instanceof</code>关键字,instanceof关键字的作用就是检测其变量类型是否属于该数据类型或者他的子类类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Train</span>(<span class="hljs-number">2000</span>,<span class="hljs-string">&quot;yellow&quot;</span>);<br><br>        <span class="hljs-comment">// 判断car是否是Train类型或者Train子类类型</span><br>        <span class="hljs-keyword">if</span>(car <span class="hljs-keyword">instanceof</span> Train)&#123;<br>            <span class="hljs-type">Train</span> <span class="hljs-variable">train</span> <span class="hljs-operator">=</span> (Train)car;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java(四)面向对象与类</title>
    <link href="/2025/05/11/Java/004Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2025/05/11/Java/004Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="note note-blue fas fa-bullhorn modern">            <p>本文档编写参考如下教程</p>          </div><ul><li><p>黑马程序员教程：<a href="https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click">黑马程序员Java零基础视频教程_上部(Java入门，含斯坦福大学练习题+力扣算法题</a></p></li><li><p>菜鸟教程：<a href="https://www.runoob.com/java/java-basic-datatypes.html">Java教程</a></p></li><li><p>CSDN TISNIW 帖子：<a href="https://blog.csdn.net/lqt214133/article/details/133123226">Java——面向对象</a></p></li><li><p>CSDN 陈一Tender 帖子：<a href="https://blog.csdn.net/wxhslwjc122333/article/details/146399969">Java面向对象编程</a></p></li><li><p>CSDN Lizhihao＿ 帖子：<a href="https://blog.csdn.net/Lizhihao_/article/details/141526635">JAVA-类和对象 （超详细）</a></p></li><li><p>CSDN Stewie Lee 帖子：<a href="https://blog.csdn.net/stewie6/article/details/143482361">Java——接口</a></p></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Java是一门<code>纯面向对象语言</code>,在面向对象的世界里,一切皆为对象。面向对象是解决问题的一种思路,主要通过对象之间的交互完成一件事情。<br>面向对象的程序是由对象组成的,每个对象包含<code>对用户公开的特定功能</code>和<code>隐藏的实现部分</code>。Java中有很多对象来自<code>标准库</code>,还有一部分由自己定义。从根本上说只要对象能够满足要求,就不必关心其功能实现过程。在<code>OOP</code>中不必关心对象的具体实现,只需其能满足用户需求即可。<br>以面向对象的方式进行处理,就不需要关注工作执行的过程。通过对象之间的交互就可以完成一件事情。面向对象编程的本质是以<code>类的方式</code>组织代码,以对象组织(封装)数据。</p><hr><h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><p><code>面向对象</code>与<code>面向过程</code>都是对项目分析,设计,开发的一种思想,它指导人们以不同的方式分析,设计和开发软件。</p><ol><li><p><code>面向过程</code>:面向过程适合简单,不需要协作的事务,重点关注执行的过程。面向过程时,需要思考怎样<code>按步骤实现</code>并将步骤对应为方法,一步步完成项目。例如把大象装进冰箱内,首先需要打开冰箱,然后把大象放进去,最后关上冰箱。</p></li><li><p><code>面向对象</code>:当思考比较复杂的设计任务时,会发现面对过程的思想比较复杂,此时面向对象的思想就应运而生了。<code>面向对象(OOP)</code>更契合人的思维模式。比如使用面向对象的思维去造车,就会想车是由轮胎,发动机,座椅,玻璃…组成的,这样只需要将这些部件组装起来就行,整个过程由这些对象之间的交互完成,而不需要关注那些对象之中的过程。因此面向对象是从整体去分析整个系统。</p></li></ol><p>面向对象与面向过程并不是编程语言,而是解决问题的一种思维方式。其中面向过程是一种执行者思维,面向对象是一种设计者思维,<code>面向对象离不开面向过程</code>。面向过程适合解决简单问题,面向对象适合解决困难的需要协作的问题。</p><h3 id="面向对象编程快速入门"><a href="#面向对象编程快速入门" class="headerlink" title="面向对象编程快速入门"></a>面向对象编程快速入门</h3><ol><li>面向对象的三个特征:<code>封装</code>,<code>继承</code>,<code>多态</code>。</li><li>创建一个一个的对象,将数据交给对象,在调用对象的方法来完成对数据的处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 类内的属性</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-comment">// 类内的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,My name is&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Main函数中....</span><br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 导包</span><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 实用类创建对象,也叫实例化对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        <span class="hljs-comment">// 给对象添加属性值</span><br>        stu.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>        stu.age = <span class="hljs-number">18</span>;<br>        stu.sex = <span class="hljs-string">&quot;男&quot;</span>;<br><br>        <span class="hljs-comment">// 使用对象调用类内的方法</span><br>        stu.hello();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="深刻认识面向对象"><a href="#深刻认识面向对象" class="headerlink" title="深刻认识面向对象"></a>深刻认识面向对象</h3><ol><li>面向对象编程的好处:<ol><li>凡事找对象的编程套路,更加符合人类思维习惯,编程也更加直观。</li></ol></li><li>对象是什么?如何创建?<ol><li>对象的本质就是一种特殊的<code>数据结构</code>(如果你学过<code>js</code>,一定对对象类型很熟悉,<code>obj=&#123;name:&#39;小明&#39;,age:18&#125;</code>,其实与这个对象差不多,只是现在说的对象更底层一点)</li><li>对象是用类new出来的,有类就可以创建对应的对象。</li><li>class也是类,也被称为对象的设计图(或者对象的模板)</li></ol></li></ol><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ol><li>类:用于描述对象里面具有的属性与行为。</li><li>对象:被类实例化创建出来,在内存中实际存在的。</li></ol><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>在JAVA中定义类时,需要使用<code>class</code>关键字。class后面的是类名,可以按照自己的取,但是要符合大坨峰命名法的规范。不止java,很多语言皆是如此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-comment">// 定义成员属性/成员方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>定义一个类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-comment">// 成员属性</span><br>    String name;<br><br>    <span class="hljs-comment">// 成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;正在吃东西&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ol><li>类名采用大坨峰命名法。</li><li>类内的属性叫做<code>成员属性/成员变量</code>,类内的方法叫做<code>成员方法/成员行为</code>。</li><li>public是来控制<code>访问权限</code>的,是封装内的内容。</li><li>一般一个文件只定义一个类。</li><li>main方法所在的类一般要使用public修饰。</li><li>public修饰的类名必须与文件名相同(尽量都保证类名与文件名相同),如果要在一个文件写多个类,那么其他类可以不用加public。</li><li>成员变量本身存在默认值,在定义成员变量时一般来说不需要初始化值。</li><li>对象与对象之间不会相互影响,但<code>多个变量指向同一个变量时就会相互影响</code>(引用类型)。</li><li>如果某个对象没有一个变量引用,那么该对象无法被操作,该对象会成为所谓的垃圾对象。</li></ol></li></ol><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><p>定义一个类,就相当于在计算机中自定义了一种新的数据类型。与int,double类似,只不过int,double是内置类型,而类是用户自定义的类型。用类创建对象的过程被称为<code>类的实例化</code>,在java中采用new关键字配合类名来实例化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 类的实例化</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        <span class="hljs-comment">// 给对象添加属性值</span><br>        stu.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>        stu.age = <span class="hljs-number">18</span>;<br>        stu.sex = <span class="hljs-string">&quot;男&quot;</span>;<br><br>        <span class="hljs-comment">// 使用对象调用类内的成员方法</span><br>        stu.hello(); <span class="hljs-comment">// 输出&quot;hello,My name is 小明&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 成员属性</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-comment">// 成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,My name is&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>注意事项</code>:当使用类实例化了一个对象后,对象身上就具备类的所有成员属性与成员方法。可以给这些属性赋值,也可以<code>通过对象调用这些成员方法</code>。当调用这个成员方法时,如果<code>成员方法内使用了成员属性</code>,那么<code>属性值应该是调用方法的对象身上的属性值</code>,而不是其他的一些什么。</p><h3 id="对象在计算机中的执行原理"><a href="#对象在计算机中的执行原理" class="headerlink" title="对象在计算机中的执行原理"></a>对象在计算机中的执行原理</h3><ol><li><code>类加载</code>:当Java程序启动时,<code>Java虚拟机(JVM)</code>会加载<code>Student</code>类和<code>Main</code>类的字节码文件,并将类的元数据信息存储到方法区中,包括类的结构,字段,方法,常量池…</li><li><code>main方法入栈</code>:JVM会调用main方法,在栈中为main方法创建一个<code>栈帧</code>。栈帧中包含main方法的局部变量,如:stu。</li><li>对象创建:在main方法中,通过new关键字创建一个对象,那么这个对象被储存在堆中,对象中包含<code>name</code>,<code>age</code>,<code>sex</code>三个字段。</li><li>方法调用:调用<code>hello方法</code>时,JVM会在栈中为hello方法创建新的栈帧,并将控制权转移到hello方法中,在hello方法执行完毕后,栈帧会被弹出栈,控制权返回main方法。</li><li>方法结束:当main方法执行完毕后,栈帧会被弹出栈,程序结束。</li><li>stu变量内记录的是对象的地址,因此变量<code>stu也是引用类型的变量</code>。</li></ol><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>this关键字</code>是java中的一个引用变量,它通常指向当前变量。在一个类的方法或<code>构造器(构造函数)</code>内,this关键字可以用来引用调用该方法或构造器的<code>对象实例</code>。this代表当前正在执行操作的对象本身。<code>哪个对象调用的方法,this就指向哪个对象</code>。</p><h3 id="使用this区分成员变量与局部变量"><a href="#使用this区分成员变量与局部变量" class="headerlink" title="使用this区分成员变量与局部变量"></a>使用this区分成员变量与局部变量</h3><p>当方法或构造函数的<code>参数名</code>与<code>类的成员变量名</code>相同时,就会产生命名冲突,如果不加以区分,编辑器默认会使用局部变量(也就是参数),而不是成员变量,这可能会导致代码逻辑错误。通过<code>this</code>关键字可以明确指定要访问的是<code>类的成员变量</code>。这一点在<code>构造函数(构造器)</code>中常常被使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Student类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-comment">// 构造函数,函数名必须与方法名一致</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age,String sex)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,my name is &quot;</span>+<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;,i am &quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot; years old,i am a &quot;</span>+<span class="hljs-built_in">this</span>.sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 项目入口</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;男&quot;</span>);<br>        <span class="hljs-comment">// stu.name = &quot;小明&quot;;</span><br>        <span class="hljs-comment">// stu.age = 18;</span><br>        <span class="hljs-comment">// stu.sex = &quot;男&quot;;</span><br><br>        stu.hello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过在构造函数内使用<code>this</code>关键字,<code>this.name = name</code>来指定对象的属性值等于传入的参数值,这样就可以在实例化对象的时候直接通过传递参数的方式来给对象属性赋值,这就是<code>构造函数</code></p><h2 id="构造器-构造函数"><a href="#构造器-构造函数" class="headerlink" title="构造器(构造函数)"></a>构造器(构造函数)</h2><p>创建对象时,对象会调用构造函数。<code>new Student()</code>,<code>Student</code>是创建对象,<code>()</code>是用来调用构造函数的。每个类都有一个构造函数,即便程序员不写,系统也会分配一个默认的构造函数。</p><ol><li>构造函数可以有多个,类似于方法的重载。</li><li>构造函数没有返回值。</li><li>构造函数不需要手动调用,程序会自动帮忙调用。</li><li>构造函数名必须与类名保持一致。</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>继承的本质就是实现对共性的抽取,同时实现代码的复用。通过对事物抽象成为一个类,类内包含这一事物的属性与行为,继承就是将这一类事物的共同属性与行为抽取出来,当在定义术语这一类事物的类时可以直接使用。而<code>抽象类</code>是因为父类提供的信息不足以描述一个具体的类,因此将父类定义为抽象类,间接加上一层效验,防止在代码中使用父类创建并使用对象。但继承也有缺点,继承是对共性的抽取,不同的对象虽然同属于一个类,但各自都会有不同的个性。</p><p>比如:动物类,狗属于动物,鸟也属于动物。但狗会跑,鸟不会。鸟会飞,狗不会。这是两者的<code>个性</code>而非共性,因此<code>父类就无法含有行为跑与行为飞</code>。可以在定义狗类时,加上自己的<code>行为跑</code>,定义鸟类时,加上自己的行为飞。可是新的问题又出现了,如果在定义一个鸭子类呢,鸭子会跑也会飞,在鸭子类中继续定义行为跑与行为飞?<code>当定义的类多了,每个类有自己单独的行为,但不同类之间又有共性,那继承的本质何在?</code></p><p><code>接口</code>可以理解为<code>对外提供一组公共的行为规范标准</code>,只要当前实例化对象符合行为规范标准,就可以让当前类<code>实现这个接口</code>。比如:定义一个接口,是行为跑的标准,狗会跑,因此狗可以实现该接口,在定义一个接口,是行为飞标准,鸟与鸭子会飞,因此鸟与鸭子可以实现这个接口</p></blockquote><ol><li><p>什么是接口?</p><p> 在Java中,<code>接口(interface)</code>是一种引用数据类型,但是它只能包含<code>常量,方法签名和嵌套类型</code>。接口不能包含实例变量或方法的实现(在Java8及以上的版本,可以定义默认方法与静态方法)。接口主要用于定义类的外部行为,并允许类实现这些行为。</p></li></ol><h3 id="接口实现与使用"><a href="#接口实现与使用" class="headerlink" title="接口实现与使用"></a>接口实现与使用</h3><ol><li><p>定义接口语法<br> 接口的定义需使用<code>interface</code>关键字</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 常量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">LEGS</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 默认有 &#x27;public static final&#x27;修饰词</span><br><br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 默认有修饰符&#x27;public abstract&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接口的实现<br> 一个类通过<code>implements</code>关键字来实现接口,并实现接口中所有的抽象方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现接口 &#x27;implements 接口名&#x27;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    <span class="hljs-comment">// 重写接口抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog类重写方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接口的使用<br> 通过接口引用实现类对象,可以实现<code>多态</code>性(有点类似于父类引用子类对象)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><br>        dog.makeSound();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><ol><li><p>方法共有性与抽象性<br> 接口中的方法都默认是public的,而且必须是public的,private和protected修饰符都不能在接口中使用。<code>接口中的所有方法都是public的,以便能够实现类访问</code>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 默认为public</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>变量默认为<code>公有静态常量</code><br> 接口中定义的变量默认是<code>public static final</code>修饰的,及静态常量。所有实现该接口的类,都可以访问这些常量。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        System.out.println(Dog.LEGS);<br>        System.out.println(Animal.LEGS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不能被实例化<br> 接口<code>不能被实例化</code>,所以<code>不支持构造函数</code>。尝试在接口中写构造函数会出现报错。<br> <code>Not allowed in interface</code></p></li><li><p>默认方法和静态方法</p><ol><li>从Java8开始,接口可以包含<code>默认方法与静态方法</code>。</li><li><code>默认方法(default)</code>:默认方法可以有<code>方法体</code>。默认方法不需要实现接口类去实现,但它们仍然是public的,使用<code>default</code>关键词修饰的是默认方法,与访问修饰符无关。</li><li><p><code>静态方法(static)</code>:静态方法也有方法体,不需要实现接口的类实现,这些方法是public的,并且可以通过接口调用。使用static修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 常量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">LEGS</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 默认有 &#x27;public static final&#x27;修饰词</span><br><br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 默认有修饰符&#x27;public abstract&#x27;</span><br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;eat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;static foo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><em>对于<code>默认方法</code>,实现这个接口的类<code>可以重写</code>它</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现接口 &#x27;implements 接口名&#x27;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    <span class="hljs-comment">// 实现接口抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog类重写方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写默认方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog 在吃&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>接口的抽象方法的实现</p><blockquote><p>一个普通类实现接口,需要将接口中的所有抽象方法实现,如果是抽象类实现接口,则是否实现抽象方法都行。</p></blockquote></li><li><p>接口之间的继承<br> 接口不能继承某个类,但<code>接口可以继承接口</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;static foo&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animals</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> Java接口支持<code>多重继承</code>,即一个接口可以继承自多个不同的接口。这与类的继承不同,类只支持单继承。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 常量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">LEGS</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 默认有 &#x27;public static final&#x27;修饰词</span><br><br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 默认有修饰符&#x27;public abstract&#x27;</span><br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;eat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;static foo&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InnerAnimal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo3</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 继承接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animals</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>,InnerAnimal&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo2</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="多重接口的实现"><a href="#多重接口的实现" class="headerlink" title="多重接口的实现"></a>多重接口的实现</h3><p>Java中,类本身无法多重继承(一个子类继承多个父类),但一个类可以实现多个接口,这样就实现了多重继承的效果。这种特殊性称为<code>多重接口实现</code>。</p><ol><li>语法<br> 一个类实现多个接口时,接口之间使用逗号分割。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现接口 &#x27;implements 接口名&#x27;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>,InnerAnimal&#123;<br>    <span class="hljs-comment">// 实现接口中的所有方法</span><br>&#125;<br></code></pre></td></tr></table></figure> 实现多个接口时,类必须实现接口中定义的所有抽象方法。如果某个接口有<code>默认方法</code>,则可以<code>重写</code>它或<code>直接使用</code></li></ol><h3 id="实现接口与继承性"><a href="#实现接口与继承性" class="headerlink" title="实现接口与继承性"></a>实现接口与继承性</h3><ol><li>继承单一性 VS 接口多实现</li></ol><p>继承性:Java中一个类只能继承一个父类,这是因为Java不支持多继承,以避免菱形继承问题。</p><p>实现接口:一个类可以实现多个接口,这允许Java类通过实现多个接口来模拟多重继承。</p><h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>抽象类</code>是用<code>abstract</code>关键字修饰的类。它<code>不能被实例化</code>,通常作为其他类的<code>父类(基类)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>&#123;<br>    <span class="hljs-comment">// 类体</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>抽象类可以包含普通方法,抽象方法,属性…。</p></blockquote><p>抽象类的特点</p><pre><code class="hljs">1. 抽象类不能直接创建对象,需要通过子类来创建对象2. 抽象类可以包含普通成员函数,构造函数,静态属性,属性,抽象方法...任意成员</code></pre><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>抽象方法使用<code>abstract</code>关键字修饰。<code>它没有方法体(即没有作用),必须由子类重写</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象方法 没有方法体</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakFa</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法没有方法体</span><br></code></pre></td></tr></table></figure><blockquote><p>抽象方法的特点</p><pre><code class="hljs">1. 抽象方法不能写主体    抽象方法只能声明,没有实现2. 抽象方法不能被`final`,`private`,`static`修饰    1. `final`:抽象方法需要被子类重写,而`final`方法不能被重写    2. `private`:抽象方法需要被子类访和实现,而`private`方法不能被子类访问    3. `static`:抽象方法依赖于实例,而`static`方法不依赖于实例。</code></pre></blockquote><h3 id="抽象方法与抽象类的关系"><a href="#抽象方法与抽象类的关系" class="headerlink" title="抽象方法与抽象类的关系"></a>抽象方法与抽象类的关系</h3><ol><li><p>抽象方法只能写在抽象类中</p><p> 如果一个类包含抽象方法,则这个类必须为抽象类。因为如果一个类包含抽象方法,那么这个类无法提供完整的实现,因此不能直接实例化,而<code>class 类名</code>的意思是可以实例化。</p></li><li><p>抽象方法可以没有抽象类</p><p> 抽象类可以不包含抽象方法,但任然不能实例化。</p></li></ol><h3 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h3><p>当一个类继承抽象类时,必须<code>实现抽象类中的所有抽象方法</code>,或者将自己也声明为抽象类。</p><ol><li><p>实现所有抽象方法,子类必须实现父类中的所有抽象方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>&#123;<br>    <span class="hljs-comment">// 抽象方法 没有方法体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakFa</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法没有方法体</span><br>&#125;<br><br><span class="hljs-comment">// 继承抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Son</span> &#123;<br><br>    <span class="hljs-comment">// 重写抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakFa</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;你好&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>声明抽象类,如果子类没有实现父类的所有抽象方法,那么子类也必须声明为抽象类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>&#123;<br>    <span class="hljs-comment">// 抽象方法 没有方法体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakFa</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法没有方法体</span><br>&#125;<br><br><span class="hljs-comment">// 继承抽象类 </span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Son</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="抽象类vs接口"><a href="#抽象类vs接口" class="headerlink" title="抽象类vs接口"></a>抽象类vs接口</h3><div class="table-container"><table><thead><tr><th>特性</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>关键字</td><td><code>abstract class</code></td><td><code>interface</code></td></tr><tr><td>实例化</td><td>无法实例化</td><td>无法实例化</td></tr><tr><td>方法实现</td><td>可以包含普通方法与抽象方法</td><td>Java8之前只能包含抽象方法</td></tr><tr><td>多继承</td><td>不支持(单继承)</td><td>支持(多实现)</td></tr><tr><td>构造器</td><td>可以有构造器</td><td>不能有构造器</td></tr><tr><td>成员变量</td><td>可以是普通变量</td><td>只能是常量(public static final)</td></tr><tr><td>设计目的</td><td>代码复用和层次设计</td><td>定义规范和扩展功能</td></tr></tbody></table></div><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>什么是内部类?<strong><em>在一个类的里面在定义一个类,就称为内部类</em></strong></p><blockquote><p>需要写一个类,描述一辆汽车。属性有车的品牌,车龄,颜色,发动机品牌以及使用年限。</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123; <span class="hljs-comment">// 外部类</span><br>String carName;<br><span class="hljs-type">int</span> carAge;<br>String color;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>&#123; <span class="hljs-comment">// 内部类</span><br>        String engineName;<br>        <span class="hljs-type">int</span> engineAge;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>1. 内部类表示的是外部类的一部分2. 内部类单独出现没有任何意义</code></pre></blockquote><p>内部类的访问特点</p><pre><code class="hljs">1. 内部类可以直接访问外部类的成员,包括私有2. 外部类要访问内部类的成员,必须创建对象</code></pre><h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><ol><li><p>成员内部类 </p><blockquote><p>写在成员位置的内部类<br>内部类方法中获取外部类中的重名成员变量</p><pre><code class="hljs"> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123; <span class="hljs-comment">// 外部类</span><br>    String carName;<br>    <span class="hljs-type">int</span> carAge;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span>;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>&#123; <span class="hljs-comment">// 内部类</span><br>        String engineName;<br>        <span class="hljs-type">int</span> engineAge;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yellow&quot;</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;orange&quot;</span>;<br>            System.out.println(color); <span class="hljs-comment">// orange</span><br>            System.out.println(<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// yellow</span><br>            System.out.println(Car.<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// red</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></blockquote></li><li><p>静态内部类</p><p> 静态内部类中只能访问<code>外部类中的静态变量与静态方法</code>,如果想要访问非静态的需要创建对象访问</p></li><li><p>局部内部类</p><p> 将内部类定义在<code>方法内</code>,就叫做局部内部类</p></li><li>匿名内部类</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java(三)数组与方法</title>
    <link href="/2025/05/11/Java/003Java%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <url>/2025/05/11/Java/003Java%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="note note-blue fas fa-bullhorn modern">            <p>本文档编写参考如下教程</p>          </div><ul><li><p>黑马程序员教程：<a href="https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click">黑马程序员Java零基础视频教程_上部(Java入门，含斯坦福大学练习题+力扣算法题</a></p></li><li><p>菜鸟教程：<a href="https://www.runoob.com/java/java-basic-datatypes.html">Java教程</a></p></li><li><p>CSDN Stewie Lee帖子：<a href="https://blog.csdn.net/stewie6/article/details/139649583">Java——重载</a></p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数据就是一个容器,可以存储<code>同种数据类型</code>的<code>多个值</code>。</p><ol><li><p>数组的定义</p><ol><li><p>第一种格式:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据类型[] 数组名 = new 数据类型[数组长度]; </span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure></li><li><p>第二种格式:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> arr[] <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure></li><li><p>数组长度默认可以省略不写。</p></li></ol></li><li><p>数组的静态初始化</p><ol><li><p>完整格式</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = <span class="hljs-keyword">new</span> 数据类型[数组长度]&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3.</span>..&#125;;<br></code></pre></td></tr></table></figure></li><li><p>简化格式</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = &#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3.</span>..&#125;;<br></code></pre></td></tr></table></figure></li><li><p>实例</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建数组,存储学生年龄</span><br><span class="hljs-type">int</span>[] ageArr = &#123;<br>    <span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>数组中的元素</p><ol><li><p>如果直接使用System.out.println()直接打印数组,会输出数组的地址值<code>[I@54bedef2</code>,而不是数组中的元素。</p><ul><li><code>[</code>表示数组的类型</li><li><code>I</code>表示数组的元素类型是int</li></ul></li><li><p>获取数组的元素</p><p> 格式:数组名[索引] 数组中的索引是从0开始的。</p></li><li><p>将数据存储到数组中</p><p> 格式:数组名[索引] = 数据/变量 // 数据会覆盖原来的值</p></li></ol></li><li><p>数组的遍历</p><p> 遍历指依次取出数组中的所有元素。<code>ageArr.length</code>表示数组的长度。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ageArr.length; i++)&#123;<br>    System.out.println(ageArr[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组其实就是一维数组内部的每个元素又是一个一维数组。也就是一维数组内部又嵌套着一维数组。</p><ol><li><p>二维数组的声明</p><ol><li><code>int[][] arr;</code></li><li><code>int arr[][];</code></li><li><code>int[] arr[];</code></li><li><code>int[] a,b[];</code>:这样声明a是一维数组,b是二维数组。</li></ol></li><li><p>二维数组的创建</p><ol><li><p>静态初始化(定义的同时赋值):</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;;<br></code></pre></td></tr></table></figure></li><li><p>动态初始化</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>因为int类型默认值为0,所以输出值全部为0。这种方式相比之前还是比较灵活的,可以通过用户<code>自行输入数组内的值</code>。</p></li></ol></li><li><p>二维数组的遍历与输出</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;;<br><br><span class="hljs-comment">// 第一层循环遍历外层数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>    <span class="hljs-comment">// 第二层循环遍历内层数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arr[i].length;j++)&#123;<br>        <span class="hljs-comment">// 打印每一个值</span><br>        System.out.println(arr[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是程序中最小的执行单元。重复的代码或有独立功能的代码抽取到方法中。</p><ol><li><p>定义与调用方法:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">playGame</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>    <span class="hljs-comment">// 返回值</span><br>    <span class="hljs-keyword">return</span> x,y;<br>&#125; <br><br><span class="hljs-comment">// 调用方法</span><br>playGame(x,y);<br></code></pre></td></tr></table></figure><p> 参数与返回值可以不写。注意:方法在调用时,参数的数量与类型必须与定义时一致,否则就会出现语法错误。</p></li><li><p>形参与实参:</p><p> 方法定义中的参数称为<code>形参</code>,方法调用时的参数称为<code>实参</code>。</p></li><li><p><code>void</code>表示无返回值类型,当方法需要返回值时,将void替换为<code>返回值的类型</code>即可</p></li></ol><h2 id="方法重载-Overload"><a href="#方法重载-Overload" class="headerlink" title="方法重载(Overload)"></a>方法重载(Overload)</h2><p>方法重载是Java中实现多态的一种方式,它允许在同一个类中定义多个<code>同名的方法</code>,只要这些方法的参数列表不同。这些不同的参数列表可以通过不同的<code>参数类型</code>,<code>参数数量</code>和<code>参数顺序</code>来实现。使用<code>println()</code>方法打印不同的数据类型,就是利用的方法重载。</p><ol><li><p>重载的条件:</p><p> 重载的条件是方法名相同,参数列表不同(<code>参数数量</code>,<code>参数类型</code>,参数顺序[参数顺序一般不用])。</p></li><li><p>重载实现:</p><ol><li><p>参数<code>类型不同</code>:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据传递的参数类型不同,调用不同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>参数<code>数量不同</code>:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据传递的参数数量不同,调用不同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>参数<code>顺序不同</code>:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据传递的参数顺序不同,调用不同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">double</span> b,<span class="hljs-type">int</span> a)</span>&#123;<br>    System.out.println(a);<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>重载的优点:</p><ol><li>提高代码可读性:使用相同的方法名称,有助于统一语义,增强代码可读性。</li><li>灵活性与简洁性:根据不同的参数进行不同的处理,增强代码的灵活性与简洁性。</li></ol></li><li><p>重载注意事项:</p><ol><li>方法返回值类型不同不能作为重载依据:方法重载与返回类型无关,只看参数列表</li><li>参数名称不同:不能作为重载依据,方法重载与参数名称无关。</li><li>方法修饰符无关:访问修饰符(public,private…)不影响方法重载。</li><li>抛出异常无关:方法抛出的异常类型与数量不会影响方法重载。</li></ol></li></ol><h2 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h2><ol><li>栈:方法运行时使用的内存,比如main方法运行。</li><li>堆:存储对象或数组,new出来的都存储在堆中。</li><li>方法区:存储可以运行的class文件</li><li>本地方法栈:JVM在使用操作系统时使用,与程序员基本无关。</li><li>寄存器:给CPU使用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java入门基础(二)各种语句</title>
    <link href="/2025/05/11/Java/002Java%E5%90%84%E7%A7%8D%E8%AF%AD%E5%8F%A5/"/>
    <url>/2025/05/11/Java/002Java%E5%90%84%E7%A7%8D%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="note note-blue fas fa-bullhorn modern">            <p>本文档编写参考如下教程</p>          </div><ul><li><p>黑马程序员教程：<a href="https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click">黑马程序员Java零基础视频教程_上部(Java入门，含斯坦福大学练习题+力扣算法题</a></p></li><li><p>菜鸟教程：<a href="https://www.runoob.com/java/java-basic-datatypes.html">Java教程</a></p></li></ul><h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2><ul><li><p>运算符：对字面量或者变量进行操作的字符,如：<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>。</p></li><li><p>表达式：用运算符把字面量或者变量连接起来符合java语法的式子,如：<code>a + b</code>。</p></li></ul><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><div class="table-container"><table><thead><tr><th>符号</th><th>作用</th><th>表达式</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>1 + 2</td></tr><tr><td>-</td><td>减</td><td>1 - 2</td></tr><tr><td>*</td><td>乘</td><td>1 * 2</td></tr><tr><td>/</td><td>除</td><td>10 / 3(整数参与计算,结果只能是整数)</td></tr><tr><td>%</td><td>取余/取模</td><td>1 % 2</td></tr><tr><td>++</td><td>自增</td><td>1++</td></tr><tr><td>—</td><td>自减</td><td>1—</td></tr></tbody></table></div><p><strong><em>在算数中如果有小数参与计算,结果有可能<code>不精确</code></em></strong></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>类似<code>+=</code>表示把左边与右边的数据相加,然后重新赋值给左边。</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;b = <span class="hljs-number">20</span>;<br>a += b; <span class="hljs-comment">// a = 30</span><br></code></pre></td></tr></table></figure></code></pre><p><code>+=,-=,*=,/=,%=</code>它们的底层都隐藏了一个强制类型转换。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>==</td><td>判断左右两边是否相等</td></tr><tr><td>!=</td><td>判断左右两边是否不相等</td></tr><tr><td>&gt;</td><td>判断左边是否大于右边</td></tr><tr><td>&lt;</td><td>判断左边是否小于右边</td></tr><tr><td>&gt;=</td><td>判断左边是否大于等于右边</td></tr><tr><td>&lt;=</td><td>判断左边是否小于等于右边</td></tr></tbody></table></div><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol><li>&amp; - 逻辑与(全为true,则满足条件)</li><li>| - 逻辑或(一个为true,则满足条件)</li><li>! - 逻辑非/<code>取反</code>(true为false,false为true)</li><li>^ - 逻辑异或(相同为false,不同为true)</li></ol><h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><p>短路逻辑运算符<code>效率比普通的逻辑运算符高</code></p><ol><li>&amp;&amp; - 短路与(左边为false,则右边不执行)</li><li>|| - 短路或(左边为true,则右边不执行)</li></ol><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>三元运算符可以用来处理简单的判断,根据判断的结果得到不同的内容。</p><p>格式： 关系表达式 ? 表达式1 : 表达式2 (true执行表达式1,false执行表达式2)</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> num1 &gt; num2 ? num1 : num2;<br><span class="hljs-comment">// 表达式为true返回num1,false返回num2</span><br></code></pre></td></tr></table></figure></code></pre><h2 id="隐式转换与强制转换"><a href="#隐式转换与强制转换" class="headerlink" title="隐式转换与强制转换"></a>隐式转换与强制转换</h2><ol><li><p>隐式转换(自动类型提升)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a; <span class="hljs-comment">// b = 10.0 隐式转换</span><br></code></pre></td></tr></table></figure><ol><li><p>取值范围小的数据与取值范围大的数据进行计算时,范围小的会优先转换为范围大的数据,然后进行计算(byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double)。</p></li><li><p>byte, short, char(ASCLL码表)三种数据类型进行计算时,都会先直接转换为int类型,然后在进行计算。</p></li></ol></li><li><p>强制类型转换:强制将一个数据类型转换为另一个数据类型。</p><p> 格式：目标数据类型 变量名 = (目标数据类型)被强转的数据;</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">12.3</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)a; <span class="hljs-comment">// b为12,强制转换数据会溢出,甚至发生数据错误</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>当<code>+</code>出现字符串时,这个<code>+</code>将不会作为算数运算符,而是用作<code>字符串的拼接</code>。</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str + num; <span class="hljs-comment">// result = &quot;hello123&quot;;</span><br></code></pre></td></tr></table></figure></code></pre><h2 id="字符相加"><a href="#字符相加" class="headerlink" title="字符相加"></a>字符相加</h2><p>当字符与<code>字符</code>或者<code>数字</code>相加时,字符会被转换为<code>ASCLL码表</code>的值进行相加。</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">0</span>; result = <span class="hljs-number">97</span><br></code></pre></td></tr></table></figure></code></pre><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><pre><code class="hljs">顺序结构是java中默认的执行流程,按照代码顺序,从上到下依次执行。</code></pre><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if语句在程序中就是用来专门判断的。如果条件满足,则执行if语句体中的内容。</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">// 进行判断</span><br><span class="hljs-keyword">if</span>(age &gt; <span class="hljs-number">18</span>)&#123;<br>    <span class="hljs-comment">// 语句体</span><br>    System.out.println(<span class="hljs-string">&quot;你以成年&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(age == <span class="hljs-number">18</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;你刚成年&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 如果条件都不满足,则执行else语句体</span><br>    System.out.println(<span class="hljs-string">&quot;未成年&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>如果语句体中,只有一句代码,`大括号可以省略不写`。</code></pre><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p><code>switch</code>语句与if语句差不多,需要注意的是,switch的匹配中是表达式的值,而不是一个条件,case后面的值<code>只能是字面量</code>,不能是变量,并且不能重复。</p><ol><li><p>语法格式:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-comment">// case中能写多个匹配的值,用逗号隔开</span><br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>, 值<span class="hljs-number">0</span>:<br>        语句体<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>        语句体<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        语句体n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>default的位置和省略</p><p> 如果<code>default</code>省略了,则如果匹配不上,则没有任何语句可以执行。default的位置其实可以放在任何位置,但是平时都会放在最下面</p></li><li><p>case穿透</p><p> 如果<code>break</code>省略,就会导致case穿透,break是用来结束case语句的,如果不写,case语句体执行完以后会继续往下执行。这像程序员的疏忽,但有时候也可以使用这种方式简化代码,使用场景很少。</p></li><li><p>switch新特性</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(number)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;星期一&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;星期二&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">default</span> -&gt; System.out.println(<span class="hljs-string">&quot;其他&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> 这是java中switch的新写法,不需要写break也不会造成<code>case穿透</code>现象。</p></li><li><p>switch与if</p><ul><li>if一般用于对<code>范围</code>的判断</li><li>switch一般用于对<code>多个值</code>进行判断</li></ul></li></ol><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ol><li><p>语法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化语句;条件判断语句;条件控制语句)&#123;<br>    循环体;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环与for循环基本一致。</p><ol><li><p>语法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">10</span>)&#123;<br>    <span class="hljs-comment">// 语句体</span><br><br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>for循环与while循环的区别</p><ol><li>for循环在知道循环次数或者循环范围的情况下使用。</li><li>while循环在不知道循环次数,不知道循环范围,只知道循环结束条件的情况下使用。</li></ol></li></ol><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><ol><li><p>语法格式</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化语句<br><span class="hljs-keyword">do</span>&#123;<br>    循环体;<br>&#125;<span class="hljs-keyword">while</span>(条件判断)<br></code></pre></td></tr></table></figure><p> do…while会先执行一次循环才会判断条件,即使条件是false也会先执行一遍。</p></li></ol><h3 id="结束循环"><a href="#结束循环" class="headerlink" title="结束循环"></a>结束循环</h3><ol><li>break结束<code>整个循环</code></li><li>continue结束本次循环,进入下次循环。</li></ol><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>java有一个内置类Random,可以生成随机数字。</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 导包</span><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>        <span class="hljs-comment">// 生成随机数,nextInt内写入随机数的范围</span><br>        <span class="hljs-comment">// 从0开始生成到10的随机数,不包括10</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java入门基础(一)基础语法</title>
    <link href="/2025/05/11/Java/001Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2025/05/11/Java/001Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="note note-blue fas fa-bullhorn modern">            <p>本文档编写参考如下教程</p>          </div><ul><li><p>黑马程序员教程：<a href="https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click">黑马程序员Java零基础视频教程_上部(Java入门，含斯坦福大学练习题+力扣算法题</a></p></li><li><p>菜鸟教程：<a href="https://www.runoob.com/java/java-basic-datatypes.html">Java教程</a></p></li></ul><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ol><li>VSCode(需要配置java环境) </li></ol><h2 id="JDK下载与安装"><a href="#JDK下载与安装" class="headerlink" title="JDK下载与安装"></a>JDK下载与安装</h2><ol><li><p>JDK下载地址:<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p></li><li><p>傻瓜式下一步安装即可(安装地址建议就使用默认的,C盘也不缺那点内存,这种程序安装地址修改了的话,后面的坑太多了)</p></li></ol><p>安装好之后,可以在安装地址找到<code>java/jdk</code>目录,其中:</p><ol><li><p><code>bin</code>: 存放各种工具命令,如：<code>javac</code>,<code>java</code></p></li><li><p>conf: 存放相关配置文件</p></li><li><p>include: 存放一些平台特定头文件</p></li><li><p>jmods: 存放各种模块</p></li><li><p>legal: 存放各种模块授权文档</p></li><li><p>lib: 存放各种工具补充JAR包</p></li></ol><h2 id="HELLO-WORLD"><a href="#HELLO-WORLD" class="headerlink" title="HELLO WORLD"></a>HELLO WORLD</h2><p>所有编程语言的开头都是<code>HELLO WORLD</code>,写个HelloWorld爽一下</p><ol><li><p>先创建一个<code>HelloWorld.java</code>文件,java文件的后缀是<code>.java</code></p></li><li><p>编写HelloWorld代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类名与文件名保持一致</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123;<br>    <span class="hljs-comment">// 入口函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">// 输出Hello World</span><br>        System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p> 当java文件运行时,<code>bin</code>目录内的<code>javac</code>工具会首先编译文件为<code>HelloWorld.class</code>文件,然后java工具才会运行<code>.class</code>文件,运行时是不加后缀的。</p></li></ol><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><ol><li><p>所有标点符号必须是英文状态下的</p></li><li><p>java内大小写严格,该大写的地方大写,该小写的地方小写。</p></li><li><p>关键词别写错了,语法不能有错误。</p></li></ol><h2 id="JAVA可以干什么"><a href="#JAVA可以干什么" class="headerlink" title="JAVA可以干什么?"></a>JAVA可以干什么?</h2><ol><li><p>Java SE：标准版。用于左面/应用开发,是其他版本的基础(桌面应用 || C/C++)。</p></li><li><p>Java ME：小型版。嵌入式电子设备/小型移动设备(嵌入式)—<code>差不多凉</code>。</p></li><li><p>Java EE：专业版。web方向的网站开发(Web网站开发<code>[浏览器&amp;服务器]</code>)。</p></li></ol><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol><li><p>面向对象：简单来说就是,根据用户想要的功能，设计出符合用户需求的对象。</p></li><li><p>安全性</p></li><li><p>多线程：同时做多件事</p></li><li><p>开源</p></li><li><p>跨平台：window || mac || linux</p></li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li><p>单行注释：<code>//</code></p></li><li><p>多行注释：<code>/* */</code></p></li><li><p>文档注释：<code>/** */</code></p></li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>创建变量时,需要在内存中申请存储空间,内存管理系统根据变量类型为变量分配空间,所以申请的空间只能存储<code>对应类型的数据</code>。</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>关键词</th><th>描述</th></tr></thead><tbody><tr><td>整数</td><td>byte(-128~127),short,int,long(L后缀)</td><td>666,-123</td></tr><tr><td>小数(浮点数)</td><td>float(F后缀),double</td><td>6.66,-12.33</td></tr><tr><td>字符串(<code>需要用双引号包裹</code>)</td><td>string</td><td>“helloworld”,”hjk”</td></tr><tr><td>字符(<code>只能用单引号包裹</code>)</td><td>char</td><td>‘a’,’b’</td></tr><tr><td>布尔值</td><td>boolean</td><td>true/false</td></tr><tr><td>空值</td><td>void</td><td>null</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xiaohu&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br><br>        System.out.println(name);<br>        System.out.println(age);<br>        System.out.println(sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在程序中存储数据的容器。</p><ol><li><p>声明变量：</p><p> 数据类型 变量名 = 值;</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(a); <span class="hljs-comment">// 输出10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>参与计算：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 变量名不能重复</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        System.out.println(a + b);<br>        System.out.println(a - b);<br>        System.out.println(a * b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意</p><ol><li>变量名不能重复</li><li>变量可以重新赋值</li><li>变量在使用前要进行<code>赋值</code></li><li>变量要在<code>作用域内</code>使用</li></ol></li></ol><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符就是程序员给类,方法,变量取的名字。JAVA中的命名规范。</p><ol><li>硬性要求<ol><li>由<code>数字,字母,下划线,$</code>组成</li><li>不能以数字开头</li><li>不能是关键字</li><li>严格区分大小写</li></ol></li><li>君子协议<ol><li><code>方法或变量名</code>使用<code>小驼峰</code>命名法(多个单词组成,第二个单词首字母大写)</li><li><code>类名</code>使用<code>大坨峰</code>名命名法(每个单词首字母大写)</li></ol></li></ol><h2 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h2><p>监听用户的键盘输入。</p><p>Java有一个内置类(<code>Scanner</code>),可以接收键盘输入的<code>数字</code>。</p><ol><li><p>导包…找到Scanner类在哪</p></li><li><p>创建实例对象</p></li><li><p>接收数据</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 导包 -- 必须在类定义的上边</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 定义类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建实例对象</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 使用sc实例对象接收数据,将数据赋值给i</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">// 打印i</span><br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>sc.nextInt()：接收一个整数。</li><li>sc.nextDouble()：接收一个小数。</li><li>sc.next()：接收一个字符串。</li></ol><h2 id="键盘输入两个数字-并求和"><a href="#键盘输入两个数字-并求和" class="headerlink" title="键盘输入两个数字,并求和"></a>键盘输入两个数字,并求和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 导包 -- 必须在类定义的上边</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 定义类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">num</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个实例</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 录入第一个数字</span><br>        System.out.println(<span class="hljs-string">&quot;请输入第一个数字&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">// 录入第二个数字</span><br>        System.out.println(<span class="hljs-string">&quot;请输入第二个数字&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">// 输出和</span><br>        System.out.println(a + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在VSCode中创建java项目"><a href="#在VSCode中创建java项目" class="headerlink" title="在VSCode中创建java项目"></a>在VSCode中创建java项目</h2><ol><li><p>进入终端输入一下内容,检查电脑内是否安装 java</p> <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">java -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure></li><li><p>安装插件<code>Extension Pack for Java</code></p></li><li><p>创建一个项目</p><ul><li>创建一个文件夹,在VSCode内,点击菜单栏的<code>查看</code>,点击<code>命令面板</code>,输入<code>java</code>或者直接CTRL + Shift + P ,输入<code>java</code></li><li>选择创建<code>java项目(create java project)</code></li><li>选择要创建什么样的java项目,一般情况下<code>Maven</code>/<code>Spring Boot</code>比较多,当然也可以什么都不选</li><li>然后输入创建的项目文件夹</li><li>输入项目名</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
